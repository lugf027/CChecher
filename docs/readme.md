### 2019 IEEE Symposium on Security and Privacy

### SoK: Sanitizing for Security

<p align="center">
    Dokyung Song, Julian Lettner, Prabhu Rajasekaran,<br/>
    Yeoul Na, Stijn Volckaert, Per Larsen, Michael Franz<br/>
    University of California, Irvine<br/>
    {dokyungs,jlettner,rajasekp,yeouln,stijnv,perl,franz}@uci.edu
</p>
***摘要***  众所周知，C和C ++编程语言是不安全的，但仍然是必不可少的。因此，开发人员会采取多管齐下的方法来解决对手面前的安全问题。这些包括手动，静态和动态程序分析。动态错误查找工具（以下称为 “消毒程序”）可以查找其他类型的分析错误，因为它们会观察程序的实际执行情况，因此可以在发生错误时直接观察错误的程序行为。

大量的消毒程序已由学术界原型化，并由从业人员完善。我们提供了消毒程序的系统概述，重点是消毒剂在发现安全问题中的作用。具体来说，我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。

#### 1、INTRODUCTION

​        C和C ++仍然是底层系统软件（例如，操作系统内核，运行时库和浏览器）的选择语言。关键原因在于它们高效且使程序员可以完全控制底层硬件。但另一方面，程序员必须确保每个内存访问都是有效的，没有计算会导致未定义的行为，等等。在实践中，程序员通常没有履行这些职责，并引入了使代码容易受到利用(容易发生漏洞并被利用这些漏洞)的错误。

​       同时，绕过(错开了)诸如地址空间布局随机化（ASLR）和数据执行保护（DEP）之类广泛采用的缓解措施，内存破坏漏洞的利用也越来越复杂[1] – [4]。代码重用攻击（例如，面向返回的编程（ROP））破坏了控制方面的数据（如函数指针或返回地址），从而劫持了程序的控制流 [1]。纯数据攻击(例如面向数据的编程（DOP）)利用 可以在合法控制流路径上调用的 指令，并通过仅破坏程序的非控制数据 来破坏程序[4]。

​        作为针对错误的第一道防线，程序员在将软件部署到生产环境之前，会使用分析工具来识别安全问题。这些工具依赖于静态程序分析、动态程序分析或静态与动态程序分析相组合。静态工具分析程序源代码，并**产生对于所有可能的代码执行都保守地正确的结果**[5] – [9]。相反，动态错误查找工具（通常称为“消毒程序”）分析单个程序执行并**输出仅对单个运行有效的精确分析结果**。

​        消毒程序现已得到广泛使用，并负责发现许多漏洞。但是，尽管它们在发现漏洞中无处不在且起着关键作用，但消毒程序通常并没有被很好地理解，这阻碍了它们的进一步发展和采用。实际上，尽管该领域有大量研究工作，但只有少数研究得到采用，从而使许多类型的漏洞都没有得到解决。本文提供了消毒程序的系统概述，重点是消毒程序在发现安全漏洞中的作用。我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。根据我们的发现，我们对开发人员的发展或研究方向提出以下三个目标（i）找到现有工具所检查不到的漏洞，（ii）改善实际中程序的兼容性（iii）更高效地找到漏洞的方法。

​        本文的其余部分安排如下：我们从对消毒程序和漏洞缓解措施两者间高层次表现比较开始（第2节）。接下来，我们描述C / C ++中的低层次漏洞（第3节）和分类技术以检测它们（第4节）。然后，我们继续介绍消毒程序的两种关键实现方法：程序检测技术（第5节）和元数据管理（第6节）。然后，我们简要讨论如何用消毒程序方式去驱动一个程序，以及如何最大化地发挥消毒程序的功效（第七节）。接下来，我们将介绍正在积极维护种 或在学术会议上发布过的消毒程序的一个汇总，重点是其精度，兼容性和性能/内存成本（第八节）。我们还将调查这些工具的部署情况（第IX节）。我们以研究方向的未来展望作为论文的结尾（第十节）。

#### 2、EXPLOIT MITIGATIONS VS. SANITIZERS

​        消毒程序在许多方面类似于许多众所周知的漏洞利用缓解措施，它们可以以类似的方式来检测程序，例如，通过插入嵌入式参考监视器（IRM）。尽管有这些相似之处，但缓解利用漏洞措施和消毒程序的目标和用例却大不相同。我们在表I中总结了主要差异。

<p align="center">表1 Exploit mitigations VS Sanitizers</p>

|                    | 漏洞利用缓解措施 | 消毒程序 |
| ------------------ | ---------------- | -------- |
| 目标               | 缓解攻击         | 查找漏洞 |
| 应用场景           | 生产             | 预发行   |
| 绩效预算           | 非常有限         | 高得多   |
| 违规结果           | 程序终止         | 问题诊断 |
| 在错误位置触发违规 | 有时             | 总是     |
| FPs公差            | 零               | 更高一点 |
| 残差良性错误的结果 | 期望的           | 不想要的 |

​        两种工具之间的最大区别在于它们执行的安全策略的类型。利用缓解措施部署旨在检测或预防攻击的策略，而消毒程序则旨在查明错误的程序语句的确切位置。控制流完整性（CFI）[10]，[11]，数据流完整性（DFI）[12]和写完整性测试（WIT）[13]是缓解漏洞的示例，因为它们检测到与合规的控制流或数据流路径之间的偏差，这通常是由于漏洞的利用而发生的，但不一定非得发生在易受攻击的程序语句的确切位置。相反，可以将边界检查工具视为消毒程序，因为违反其策略的行为直接在易受攻击的语句位置触发。

​        一些工具有选择地应用消毒技术，可能还结合了漏洞利用缓解措施的技术。例如，代码指针完整性（CPI）仅在程序直接或间接访问敏感代码指针时才执行边界检查（许多消毒程序中使用的一种消毒程序技术）[14]。因此，我们将CPI视为一种漏洞利用缓解措施的方法，而不是一种消毒程序，因为CPI仅检测可以使用边界检查检测到的所有错误的一小部分。

​        漏洞利用缓解措施的目的是在生产中部署，因此对各个设计方面提出了严格的要求。首先，漏洞利用缓解措施如果导致不可忽略的运行时间开销，则很少能被实际采用[15]。消毒程序对性能的要求不那么严格，因为它们仅用于测试。第二，漏洞利用缓解措施中的误报检测是不可接受的（也就是对容错性要求较高），因为它们会终止程序。而如果开发人员本意是查看错误报告（报错日志），则消毒程序可以容忍错误的警报。最后，出于可靠性和可用性的原因，在生产系统中允许存在残差的良性错误（例如，写入填充），并且经常会希望这种良性错误；而消毒程序的目的是精确地检测这些错误，因为它们的可利用性（就是程序到底会不会执行到这一段代码）未知。

#### 3. LOW - LEVEL VULNERABILITIES

​    鉴于与安全性相关的漏洞种类繁多，我们将重点介绍在C / C ++中具有特定安全性的漏洞。这不仅包括未定义的行为，还包括在缺乏类型和内存安全性的情况下可能具有潜在危险的定义良好的行为。我们简述这些错误以及如何利用它们来泄漏信息、提升特权或执行任意代码。

1. 违反内存安全

   ​        如果程序中的指针仅访问其  intended referents，而这些预期的引用是有效的，则该程序是 memory safe 。指针的预期对象是从其基址派生指针的对象。根据引用对象的类型，它在其分配和释放之间（对于堆分配的引用对象）、在函数调用与其返回（对于堆栈分配的引用对象）之间，在其关联线程的创建和销毁之间都是有效的（对于线程本地引用）或无期限的（对于全局引用）。

   ​        违反内存安全性是最严重的安全漏洞之一，并且在文献[15]，[16]中进行了广泛的研究。他们的利用可能导致代码注入[17]，控制流劫持[1]，[18]，[19]，特权升级[20]，信息泄漏[21]和程序崩溃。

   * ***空间安全违规***：访问不（完全）在指针的预期引用范围之内的内存构成空间安全违规。缓冲区溢出是违反空间安全性的典型示例。当程序超出缓冲区末尾写入时，将发生缓冲区溢出。如果易受攻击的访问的目标对象是一个子对象（例如，结构字段），并且如果攻击者在同一对象内写入另一个子对象，则我们将其称为  intra-object overflow 。清单1显示了一个对象内溢出漏洞，可以利用该漏洞执行特权升级攻击。

     <p align="center">清单1. 对象内溢出漏洞，可以利用该漏洞<br>重写对安全敏感的、非控制数据</p>

     ```c
     struct A { char name[7]; bool isAdmin; };
     struct A a; char buf[8];
     memcpy(/* dst */ a.name, /* src */ buf, sizeof(buf));
     ```

   * ***违反时间安全性***：当程序访问不再有效的引用时，发生违反时间安全性的行为。当一个对象变为无效时（通常是通过显式地对其进行分配），指向该对象的所有指针都将变为 dangling 。通过悬空指针访问对象被称为  use-after-free。访问的其范围或在函数返回之后本地对象外分别被称为  use-after-scope 和 use-after-return 。当攻击者可以重用和控制释放的区域时，这种类型的漏洞就可以被利用，如清单2所示。

     <p align="center">清单2. Use-after-free 的漏洞，可以被利用来劫持程序的控制流</p>

     ```c
     struct A { void (*func)(void); };
     struct A *p = (struct A *)malloc(sizeof(struct A));
     free(p); // Pointer becomes dangling
     ...
     p->func(); // Use-after-free
     ```

2. 使用未初始化的变量

   ​        变量在初始化之前具有  indeterminate value [22]，[23]。如果源变量和目标变量都具有无符号的窄字符类型，则C++14允许将此不确定值赋给其他变量。任何未初始化变量的使用都会导致未定义的行为。这种不确定行为的影响取决于许多因素，包括用于编译程序的编译器和编译器标志。在大多数情况下，不确定值实际上是先前释放的变量的（部分）内容，这些变量所占用的内存位置与未初始化的变量相同。由于这些先前释放的变量有时可能对安全性敏感值，未初始化的内存的读取可能是信息泄漏攻击的一部分，如清单3所示。

   <p align="center">清单3.使用部分初始化的变量，该变量在未初始化的值<br/>越过可信任边界时会变得易受攻击</p>

   ```c
   struct A { int data[2]; };
   struct A *p = (struct A *)malloc(sizeof(struct A));
   p->data[0] = 0; // Partial initialization
   send_to_untrusted_client(p, sizeof(struct A));
   ```

3. 指针类型错误

   ​        C 和 C ++ 支持多种强制转换运算符和语言构造，这些构造运算符和语言构造可能导致内存访问错误地解释了其引用对象中存储的数据，从而违反了类型安全性。指针类型错误通常是由不安全的强制转换引起的。C 允许在指针类型之间进行所有类型转换，包括在整数和指针类型之间进行类型转换。同样，C++ reinterpret_cast 类型转换运算符不受任何限制。而 static_cast 和 dynamic_cast 的操作有所限制限制。static_cast 禁止指向整数强制转换的指针，以及禁止指向与继承无关的对象的指针之间的强制转换。但是，它的确允许将指针从基类强制转换为派生类（也称为downcasting ），以及从void 类型进行的所有强制转换。当向下转换的指针既没有其引用对象的运行时的类型，也没有引用对象的祖先类型之一时，就会发生 bad-casting（通常称为 type confusion）。

   <p align="center">清单4. 错误转换漏洞导致类型和内存不安全的内存访问</p>

   ```c
   class Base { virtual void func(); };
   class Derived : public Base { public: int extra; };
   Base b[2];
   Derived * d = static_cast<Derived * >(&b[0]); // Bad-casting
   d->extra = ...; // Type-unsafe, out-of-bounds access, which
                   // overwrites the vtable pointer of b[1]
   ```

   ​        为了安全地向下转换，程序员必须使用 dynamic_cast 运算符，该运算符执行运行时类型检查，如果检查失败，则返回空指针。但是，使用 dynamic_cast 完全是可选的（非必需的），并且会带来额外的运行时开销。

   ​    在函数指针类型之间进行转换时，也会发生类型错误。同样，C ++ 的 reinterpret_cast 和 C 对不兼容的函数指针类型之间的强制转换没有任何限制。如果通过错误类型的函数指针间接调用函数，则目标函数可能会错误地编译(误解)其参数，从而导致更多类型错误。最后，C 还允许通过 union 类型进行类型修剪。如果程序通过转换实际存储数据的成员对象到不同的其他类型成员对象的方式去读取 union，则可能会误解底层的内存内容。此外，如果用于读取的成员对象大于用于存储数据的成员对象，则从 union 中读取的高位字节将采用未指定的值。

4. 可变参数功能滥用

   ​    C / C ++支持  variadic functions，除了固定数量的常规函数参数外，它们还接受可变数量的可变长函数参数。可变参数函数的源代码未指定这些可变参数的数量或类型。相反，固定参数和函数语义对可变参数的预期数量和类型进行编码。可变参数可以使用 va_arg 进行访问并同时进行类型转换。通常，不可能静态验证 va_arg 访问有效参数，或将参数转换为有效类型。缺少静态验证会导致类型错误，违反空间内存安全性以及使用未初始化的值。

   <p align="center">清单5. CVE-2012-0809的 简化版本；用户提供的输入<br>被误用作传递给类似 printf() 的较大格式字符串的一部分</p>

   ```c
   char * fmt2; // User-controlled format string
   sprintf(fmt2, user_input, ...);
   // prints attacker-chosen stack contents if fmt2 contains
   // too many format specifiers
   // or overwrites memory if fmt2 contains %n
   printf(fmt2, ...);
   ```

5. 其他漏洞

​        在没有类型和内存安全性的情况下，还有其他操作可能会带来安全风险。值得注意的例子包括溢出错误，当在内存分配或指针算术运算中使用此类值时，可能会利用这些错误。如果使用攻击者控制的整数值来计算缓冲区大小或数组索引，则攻击者可能使该值溢出以分配比预期小的缓冲区（如清单6所示），或者绕过现有的数组索引检查，从而触发一个出界外的访问。

<p align="center">清单6. CVE-2017-5029的简化版本；有符号整数溢出漏洞，<br>可能导致违反空间内存安全性</p>

```c
// newsize can overflow depending on len
int newsize = oldsize + len + 100;
newsize * = 2;
// The new buffer may be smaller than len
buf = xmlRealloc(buf, newsize);
memcpy(buf + oldsize, string, len); // Out-of-bounds access
```

​        C / C ++并未定义有符号整数溢出的结果，但规定无符号整数溢出时会回绕。但是，这种环绕行为通常是意料之外的，并且有潜在的危险。

​        启用编译器优化后，未定义的行为（例如，有符号整数溢出）会带来额外的安全风险。在存在潜在未定义行为的情况下，编译器被默认允许假定程序将永远不会达到触发此未定义行为的条件。而且，编译器可以基于此假设[24]执行进一步的优化。因此，编译器不必静态验证程序是否没有潜在的未定义行为，并且编译器没有义务生成能够识别或减少未定义行为的代码。这个基本原理的问题在于，基于程序没有未定义行为的假设进行的优化有时会导致编译器忽略安全检查。例如在CVE-2009-1897中，海湾合作委员会臭名昭著地省略了Linux内核驱动程序之一中的空指针检查，这导致了提权漏洞[25]。编译器开发人员会定期向其编译器中添加此类积极的优化。因此，有些人将未定义的行为称为 time bombs [26]。

<p align="center">清单7. CVE-2009-1897的简化版本；取消引用指针<br>可使编译器安全地假定指针为非null</p>

```c
struct sock *sk = tun->sk; // Compiler assumes tun is not 
                           // a null pointer
if (!tun) // Check is optimized out
    return POLLERR;
```

#### IV. BUG FINDING TECHNIQUES



#### V. PROGRAM INSTRUMENTATION



#### VI. META DATA MANAGEMENT



#### VII.  RIVING A SANITIZER



#### VIII. ANALYSIS



#### IX. DEPLOYMENT



#### X. FUTURE RESEARCH AND DEVELOPMENT DIRECTIONS

