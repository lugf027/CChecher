# 2019 IEEE Symposium on Security and Privacy

# SoK: Sanitizing for Security

<p align="center">
    Dokyung Song, Julian Lettner, Prabhu Rajasekaran,<br/>
    Yeoul Na, Stijn Volckaert, Per Larsen, Michael Franz<br/>
    University of California, Irvine<br/>
    {dokyungs,jlettner,rajasekp,yeouln,stijnv,perl,franz}@uci.edu
</p>


[TOC]



## 摘要

​	众所周知，C和C ++编程语言是不安全的，但仍然是必不可少的。因此，开发人员会采取多管齐下的方法来解决对手面前的安全问题。这些包括手动，静态和动态程序分析。动态错误查找工具（以下称为 “消毒程序”）可以查找其他类型的分析错误，因为它们会观察程序的实际执行情况，因此可以在发生错误时直接观察错误的程序行为。

​	大量的消毒程序已由学术界原型化，并由从业人员完善。我们提供了消毒程序的系统概述，重点是消毒剂在发现安全问题中的作用。具体来说，我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。

## 1、INTRODUCTION

​        C和C ++仍然是底层系统软件（例如，操作系统内核，运行时库和浏览器）的选择语言。关键原因在于它们高效且使程序员可以完全控制底层硬件。但另一方面，程序员必须确保每个内存访问都是有效的，没有计算会导致未定义的行为，等等。在实践中，程序员通常没有履行这些职责，并引入了使代码容易受到利用(容易发生漏洞并被利用这些漏洞)的错误。

​       同时，绕过(错开了)诸如地址空间布局随机化（ASLR）和数据执行保护（DEP）之类广泛采用的缓解措施，内存破坏漏洞的利用也越来越复杂[1] – [4]。代码重用攻击（例如，面向返回的编程（ROP））破坏了控制方面的数据（如函数指针或返回地址），从而劫持了程序的控制流 [1]。纯数据攻击(例如面向数据的编程（DOP）)利用 可以在合法控制流路径上调用的 指令，并通过仅破坏程序的非控制数据 来破坏程序[4]。

​        作为针对错误的第一道防线，程序员在将软件部署到生产环境之前，会使用分析工具来识别安全问题。这些工具依赖于静态程序分析、动态程序分析或静态与动态程序分析相组合。静态工具分析程序源代码，并**产生对于所有可能的代码执行都保守地正确的结果**[5] – [9]。相反，动态错误查找工具（通常称为“消毒程序”）分析单个程序执行并**输出仅对单个运行有效的精确分析结果**。

​        消毒程序现已得到广泛使用，并负责发现许多漏洞。但是，尽管它们在发现漏洞中无处不在且起着关键作用，但消毒程序通常并没有被很好地理解，这阻碍了它们的进一步发展和采用。实际上，尽管该领域有大量研究工作，但只有少数研究得到采用，从而使许多类型的漏洞都没有得到解决。本文提供了消毒程序的系统概述，重点是消毒程序在发现安全漏洞中的作用。我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。根据我们的发现，我们对开发人员的发展或研究方向提出以下三个目标（i）找到现有工具所检查不到的漏洞，（ii）改善实际中程序的兼容性（iii）更高效地找到漏洞的方法。

​        本文的其余部分安排如下：我们从对消毒程序和漏洞缓解措施两者间高层次表现比较开始（第2节）。接下来，我们描述C / C ++中的低层次漏洞（第3节）和分类技术以检测它们（第4节）。然后，我们继续介绍消毒程序的两种关键实现方法：程序检测技术（第5节）和元数据管理（第6节）。然后，我们简要讨论如何用消毒程序方式去驱动一个程序，以及如何最大化地发挥消毒程序的功效（第七节）。接下来，我们将介绍正在积极维护种 或在学术会议上发布过的消毒程序的一个汇总，重点是其精度，兼容性和性能/内存成本（第八节）。我们还将调查这些工具的部署情况（第IX节）。我们以研究方向的未来展望作为论文的结尾（第十节）。

## 2、EXPLOIT MITIGATIONS VS. SANITIZERS

​        消毒程序在许多方面类似于许多众所周知的漏洞利用缓解措施，它们可以以类似的方式来检测程序，例如，通过插入嵌入式参考监视器（IRM）。尽管有这些相似之处，但缓解利用漏洞措施和消毒程序的目标和用例却大不相同。我们在表I中总结了主要差异。

<p align="center">表1 Exploit mitigations VS Sanitizers</p>

|                    | 漏洞利用缓解措施 | 消毒程序 |
| ------------------ | ---------------- | -------- |
| 目标               | 缓解攻击         | 查找漏洞 |
| 应用场景           | 生产             | 预发行   |
| 绩效预算           | 非常有限         | 高得多   |
| 违规结果           | 程序终止         | 问题诊断 |
| 在错误位置触发违规 | 有时             | 总是     |
| FPs公差            | 零               | 更高一点 |
| 残差良性错误的结果 | 期望的           | 不想要的 |

​        两种工具之间的最大区别在于它们执行的安全策略的类型。利用缓解措施部署旨在检测或预防攻击的策略，而消毒程序则旨在查明错误的程序语句的确切位置。控制流完整性（CFI）[10]，[11]，数据流完整性（DFI）[12]和写完整性测试（WIT）[13]是缓解漏洞的示例，因为它们检测到与合规的控制流或数据流路径之间的偏差，这通常是由于漏洞的利用而发生的，但不一定非得发生在易受攻击的程序语句的确切位置。相反，可以将边界检查工具视为消毒程序，因为违反其策略的行为直接在易受攻击的语句位置触发。

​        一些工具有选择地应用消毒技术，可能还结合了漏洞利用缓解措施的技术。例如，代码指针完整性（CPI）仅在程序直接或间接访问敏感代码指针时才执行边界检查（许多消毒程序中使用的一种消毒程序技术）[14]。因此，我们将CPI视为一种漏洞利用缓解措施的方法，而不是一种消毒程序，因为CPI仅检测可以使用边界检查检测到的所有错误的一小部分。

​        漏洞利用缓解措施的目的是在生产中部署，因此对各个设计方面提出了严格的要求。首先，漏洞利用缓解措施如果导致不可忽略的运行时间开销，则很少能被实际采用[15]。消毒程序对性能的要求不那么严格，因为它们仅用于测试。第二，漏洞利用缓解措施中的误报检测是不可接受的（也就是对容错性要求较高），因为它们会终止程序。而如果开发人员本意是查看错误报告（报错日志），则消毒程序可以容忍错误的警报。最后，出于可靠性和可用性的原因，在生产系统中允许存在残差的良性错误（例如，写入填充），并且经常会希望这种良性错误；而消毒程序的目的是精确地检测这些错误，因为它们的可利用性（就是程序到底会不会执行到这一段代码）未知。

## 3. LOW - LEVEL VULNERABILITIES

​        鉴于与安全性相关的漏洞种类繁多，我们将重点介绍在C / C ++中具有特定安全性的漏洞。这不仅包括未定义的行为，还包括在缺乏类型和内存安全性的情况下可能具有潜在危险的定义良好的行为。我们简述这些错误以及如何利用它们来泄漏信息、提升特权或执行任意代码。

### 3.1 违反内存安全(Memory Safety Violations)

​        如果程序中的指针仅访问其  intended referents，而这些预期的引用是有效的，则该程序是 memory safe 。指针的预期对象是从其基址派生指针的对象。根据引用对象的类型，它在其分配和释放之间（对于堆分配的引用对象）、在函数调用与其返回（对于堆栈分配的引用对象）之间，在其关联线程的创建和销毁之间都是有效的（对于线程本地引用）或无期限的（对于全局引用）。

​        违反内存安全性是最严重的安全漏洞之一，并且在文献[15]，[16]中进行了广泛的研究。他们的利用可能导致代码注入[17]，控制流劫持[1]，[18]，[19]，特权升级[20]，信息泄漏[21]和程序崩溃。

#### 3.1.1 空间安全违规 ( Spatial Safety Violations)：

​        访问不（完全）在指针的预期引用范围之内的内存构成空间安全违规。缓冲区溢出是违反空间安全性的典型示例。当程序超出缓冲区末尾写入时，将发生缓冲区溢出。如果易受攻击的访问的目标对象是一个子对象（例如，结构字段），并且如果攻击者在同一对象内写入另一个子对象，则我们将其称为  intra-object overflow 。清单1显示了一个对象内溢出漏洞，可以利用该漏洞执行特权升级攻击。

<p align="center">清单1. 对象内溢出漏洞，可以利用该漏洞重写对安全敏感的、非控制数据</p>

```c
struct A { char name[7]; bool isAdmin; };
struct A a; char buf[8];
memcpy(/* dst */ a.name, /* src */ buf, sizeof(buf));
```

#### 3.1.2 违反时间安全性(Temporal Safety Violations)：

当程序访问不再有效的引用时，发生违反时间安全性的行为。当一个对象变为无效时（通常是通过显式地对其进行分配），指向该对象的所有指针都将变为 dangling 。通过悬空指针访问对象被称为  use-after-free。访问的其范围或在函数返回之后本地对象外分别被称为  use-after-scope 和 use-after-return 。当攻击者可以重用和控制释放的区域时，这种类型的漏洞就可以被利用，如清单2所示。

<p align="center">清单2. Use-after-free 的漏洞，可以被利用来劫持程序的控制流</p>

```c
struct A { void (*func)(void); };
struct A *p = (struct A *)malloc(sizeof(struct A));
free(p); // Pointer becomes dangling
...
p->func(); // Use-after-free
```

### 3.2 使用未初始化的变量(Use of Uninitialized Variables)

​        变量在初始化之前具有  indeterminate value [22]，[23]。如果源变量和目标变量都具有无符号的窄字符类型，则C++14允许将此不确定值赋给其他变量。任何未初始化变量的使用都会导致未定义的行为。这种不确定行为的影响取决于许多因素，包括用于编译程序的编译器和编译器标志。在大多数情况下，不确定值实际上是先前释放的变量的（部分）内容，这些变量所占用的内存位置与未初始化的变量相同。由于这些先前释放的变量有时可能对安全性敏感值，未初始化的内存的读取可能是信息泄漏攻击的一部分，如清单3所示。

<p align="center">清单3.使用部分初始化的变量，该变量在未初始化的值越过可信任边界时会变得易受攻击</p>

```c
struct A { int data[2]; };
struct A *p = (struct A *)malloc(sizeof(struct A));
p->data[0] = 0; // Partial initialization
send_to_untrusted_client(p, sizeof(struct A));
```

### 3.3 指针类型错误（Pointer Type Errors）

​        C 和 C ++ 支持多种强制转换运算符和语言构造，这些构造运算符和语言构造可能导致内存访问错误地解释了其引用对象中存储的数据，从而违反了类型安全性。指针类型错误通常是由不安全的强制转换引起的。C 允许在指针类型之间进行所有类型转换，包括在整数和指针类型之间进行类型转换。同样，C++ reinterpret_cast 类型转换运算符不受任何限制。而 static_cast 和 dynamic_cast 的操作有所限制限制。static_cast 禁止指向整数强制转换的指针，以及禁止指向与继承无关的对象的指针之间的强制转换。但是，它的确允许将指针从基类强制转换为派生类（也称为downcasting ），以及从void 类型进行的所有强制转换。当向下转换的指针既没有其引用对象的运行时的类型，也没有引用对象的祖先类型之一时，就会发生 bad-casting（通常称为 type confusion）。

<p align="center">清单4. 错误转换漏洞导致类型和内存不安全的内存访问</p>

```c
class Base { virtual void func(); };
class Derived : public Base { public: int extra; };
Base b[2];
Derived * d = static_cast<Derived * >(&b[0]); // Bad-casting
d->extra = ...; // Type-unsafe, out-of-bounds access, which
                // overwrites the vtable pointer of b[1]
```

​        为了安全地向下转换，程序员必须使用 dynamic_cast 运算符，该运算符执行运行时类型检查，如果检查失败，则返回空指针。但是，使用 dynamic_cast 完全是可选的（非必需的），并且会带来额外的运行时开销。

​        在函数指针类型之间进行转换时，也会发生类型错误。同样，C ++ 的 reinterpret_cast 和 C 对不兼容的函数指针类型之间的强制转换没有任何限制。如果通过错误类型的函数指针间接调用函数，则目标函数可能会错误地编译(误解)其参数，从而导致更多类型错误。最后，C 还允许通过 union 类型进行类型修剪。如果程序通过转换实际存储数据的成员对象到不同的其他类型成员对象的方式去读取 union，则可能会误解底层的内存内容。此外，如果用于读取的成员对象大于用于存储数据的成员对象，则从 union 中读取的高位字节将采用未指定的值。

### 3.4 可变参数功能滥用 ( Variadic Function Misuse)

​    C / C ++支持  variadic functions，除了固定数量的常规函数参数外，它们还接受可变数量的可变长函数参数。可变参数函数的源代码未指定这些可变参数的数量或类型。相反，固定参数和函数语义对可变参数的预期数量和类型进行编码。可变参数可以使用 va_arg 进行访问并同时进行类型转换。通常，不可能静态验证 va_arg 访问有效参数，或将参数转换为有效类型。缺少静态验证会导致类型错误，违反空间内存安全性以及使用未初始化的值。

<p align="center">清单5. CVE-2012-0809的 简化版本；用户提供的输入<br>被误用作传递给类似 printf() 的较大格式字符串的一部分</p>

```c
char * fmt2; // User-controlled format string
sprintf(fmt2, user_input, ...);
// prints attacker-chosen stack contents if fmt2 contains
// too many format specifiers
// or overwrites memory if fmt2 contains %n
printf(fmt2, ...);
```

### 3.5 其他漏洞 (Other Vulnerabilities)

​        在没有类型和内存安全性的情况下，还有其他操作可能会带来安全风险。值得注意的例子包括溢出错误，当在内存分配或指针算术运算中使用此类值时，可能会利用这些错误。如果使用攻击者控制的整数值来计算缓冲区大小或数组索引，则攻击者可能使该值溢出以分配比预期小的缓冲区（如清单6所示），或者绕过现有的数组索引检查，从而触发一个出界外的访问。

<p align="center">清单6. CVE-2017-5029的简化版本；有符号整数溢出漏洞，<br>可能导致违反空间内存安全性</p>

```c
// newsize can overflow depending on len
int newsize = oldsize + len + 100;
newsize * = 2;
// The new buffer may be smaller than len
buf = xmlRealloc(buf, newsize);
memcpy(buf + oldsize, string, len); // Out-of-bounds access
```

​        C / C ++并未定义有符号整数溢出的结果，但规定无符号整数溢出时会回绕。但是，这种环绕行为通常是意料之外的，并且有潜在的危险。

​        启用编译器优化后，未定义的行为（例如，有符号整数溢出）会带来额外的安全风险。在存在潜在未定义行为的情况下，编译器被默认允许假定程序将永远不会达到触发此未定义行为的条件。而且，编译器可以基于此假设[24]执行进一步的优化。因此，编译器不必静态验证程序是否没有潜在的未定义行为，并且编译器没有义务生成能够识别或减少未定义行为的代码。这个基本原理的问题在于，基于程序没有未定义行为的假设进行的优化有时会导致编译器忽略安全检查。例如在CVE-2009-1897中，海湾合作委员会臭名昭著地省略了Linux内核驱动程序之一中的空指针检查，这导致了提权漏洞[25]。编译器开发人员会定期向其编译器中添加此类积极的优化。因此，有些人将未定义的行为称为 time bombs [26]。

<p align="center">清单7. CVE-2009-1897的简化版本；取消引用指针<br>可使编译器安全地假定指针为非null</p>

```c
struct sock *sk = tun->sk; // Compiler assumes tun is not 
                           // a null pointer
if (!tun) // Check is optimized out
    return POLLERR;
```

## 4. BUG FINDING TECHNIQUES

​        现在，我们回顾相关的错误查找技术。我们在每个小节中都以对错误发现策略的非正式描述开头，然后对实现（或近似）该策略的机制进行描述。

### 4.1 违反内存安全 (Memory Safety Violations)

​        内存安全错误查找工具会检测未针对其预期目标（即，违反空间安全）或针对不再有效的目标（即，违反时间安全）的指针的间接引用。有两种检测这些错误的工具。我们在这里总结了它们的高级目标和属性，然后深入讨论了这些工具可用来检测内存安全错误的技术。

**基于位置的访问检查器 (Location-based Access Checkers)：**

​        基于位置的访问检查器检测内存访问无效的内存区域。这些检查器具有一个元数据存储，该存储可维护每个字节（一部分）可寻址地址空间中的状态，并且每当程序尝试访问内存以确定内存访问是否有效时，都应查阅该元数据存储。基于位置的访问检查器可以使用 red zones插入 [27] – [31]或保护页[32]，[33]来检测空间安全违规情况。这些技术中的任何一种都可以与重用延迟结合使用，以另外检测时间安全性违规 [27]-[29]， [31]-[36]。 基于位置的访问检查器的费用较低运行时性能开销，并且与非仪表代码（uninstrumented code）高度兼容。缺点是这些工具不精确，因为它们只能检测指令是否访问有效内存，而*不能检测访问的内存是否是指令的预期对象的一部分( not if the accessed memory is part of the intended referent of the instruction)*。这些(?)工具通常会导致高内存开销。

**基于身份的访问检查器（Identity-based Access Checkers):**

​        基于身份的访问检查器检测与预期引用对象不匹配的内存地址访问。这些工具为每个分配的内存对象维护元数据（例如，边界或分配状态），并且具有适当的机制来确定程序中每个指针间接引用以确定该引用是否访问该指针的预期引用时，会发生元数据查找。基于身份的访问检查器可以使用按对象边界跟踪[34]， [37]-[43]或按指针边界跟踪[44] – [55] 可以检测到违反空间安全的行为，并且可以通过重用延迟[55]，锁定和钥匙检查[46]，[47]，[56]或悬置指针标记[57] – [60] 进行扩展。检测临时安全违规。基于身份的检查器比基于位置的访问检查器更为精确，因为它们不仅可以检测到对无效内存的访问，而且还可以检测对预期对象以外的有效内存的访问。但是，与基于位置的检查器相比，这些工具确实会带来更高的运行时性能开销。基于身份的检查器通常与非仪表代码不兼容。他们的假阳性检出率也比基于位置的检查器。

#### 4.1.1 违反空间内存安全 (Spatial Memory Safety Violations)：

**红色区域插入 (Red-zone Insertion)**：

​        基于位置的访问检查器可以在内存对象 [27] – [31]之间插入所谓的  red-zones。这些 red-zones 表示内存访问越界，并在元数据存储中标记为无效内存。对 red-zones 或未分配的内存区域的任何访问都会触发警告。Purify 是采用该技术的第一个工具[27]。Purify 在每个分配的开始和结束插入 red zones。Purify使用大型影子内存位图跟踪程序分配的地址空间的状态，该位图在每个字节的内存中存储两位状态。Valgrind 的 Memcheck 使用相同的技术，但为内存的每一位保留两位状态[28]。因此，Memcheck 能够以字级精度而不是字节级精度检测访问错误。

​        轻量级边界检查（LBC）同样会插入 red zones，但为基于位置的访问检查添加了一条快速路径，以减少元数据查找的开销[30]。LBC 通过用随机模式填充 red zones 来做到这一点，并将每个内存访问读取/覆盖的数据与填充模式进行比较。如果数据与填充模式不匹配，则认为该访问是安全的，因为它不可能被标记为 red zones。如果数据确实符合填充模式，则 LBC 将执行辅助慢路径检查，以查找元数据存储中已访问数据的状态，并在已访问数据为 red zones 时触发警告。

​        使用红区插入的基于位置的访问检查器通常会产生较低的运行时性能开销，但精度有限，因为它们只能检测到针对红区的非法访问。以有效对象为目标的非法访问是无法检测到，因为该对象与预期的对象可能同为某一分配的一部分，也可能不是的。基于 red zones 插入的工具也无法检测对象内部的溢出错误，因为它们没有在子对象之间插入 red zones。在技术上可行时，插入子对象间的 red zones 时会导致过多的内存开销，并且会更改父对象的布局。因此，必须修改访问父对象或其子对象之一的任何代码，这也将破坏未意识到数据布局已更改的外部代码的兼容性。

**保护页面 (Guard Pages)**：

​        基于位置的访问检查器可以在每个分配的内存对象[32]-[33]之前和(或)之后插入不可访问的保护页面。访问保护页的越界读取和写入会触发页面错误，这又会触发应用程序中的异常。使用分页硬件检测非法访问允许基于位置无需检查单个 load 和 store 指令即可访问检查程序。但是，使用保护页确实会导致高内存开销，从而使该技术对于具有较大工作集的程序不切实际。Microsoft 意识到了这个问题，并在 PageHeap [33]中添加了一个选项，使内存对象带有保护块而不是完整的保护页。PageHeap 使用填充模式填充这些保护块，并保证释放内存对象时该模式仍然存在。此技术严格不如红区插入，因为它仅检测越界写入(而不读取)，并且除非要写入的对象被释放，否则不会检测到非法写入。

**每个指针的边界跟踪(Per-pointer Bounds Tracking)：**

​        基于身份的访问检查器可以存储每个指针的边界元数据[44]-[55]。每当程序通过调用 malloc 或通过获取对象的地址创建指针时，跟踪器都会为新指针将其引用对象的基址和空间大小存进元数据。当程序通过算术和赋值运算计算新的指针时，跟踪器将传播(propagates)此元数据。通过检测所有指针间接引用并检查指针在简介引用时是否在其关联边界之外，可以检测到空间内存安全冲突。

​        使用基于指针的边界跟踪的基于身份的访问检查器可以提供完整的空间内存冲突检测，包括检测对象内溢出。每当程序从子对象的地址（即结构域）派生指针时，SoftBound [48]和 Intel Pointer Checker [49] 通过将指针范围缩小到子对象的边界来检测对象内溢出。每指针边界跟踪的主要缺点是兼容性差，因为该程序通常无法将指针传递给未插入库，因为此类库无法正确传播或更新边界信息。另一个缺点是每个指针元数据传播会增加运行时的开销。CCured 通过标识“安全”指针来减少这种开销，可以将其从边界检查和元数据传播中排除[50]。然而，即使有了这种优化，没有硬件支持，每个指针的边界检查仍然很昂贵。

**每个对象的边界跟踪(Per-object Bounds Tracking)**：

​        基于身份的访问检查器还可以存储每个内存对象的边界元数据，而不是每个指针的边界元数据[34]， [37] – [43]。

​        这种方法是由 Jones 和 Kelly（下称：“J＆K”）率先提出的，解决了一些与每指针边界跟踪有关的兼容性问题[34]。Per-object Bounds Tracking 可以维护边界元数据，而无需检测指针的创建和分配操作。跟踪器仅需要拦截对内存分配（即 malloc ）和释放（ 即free ）函数的调用，即使在未完全检测的程序中也可以实现。由于边界元数据仅为对象而不是指针维护，因此很难将指针链接到其预期的引用对象。虽然内部指针类型的预期引用对象可以使用基于（生命周期）范围的查找，来在元数据中的存储，但这样的查找将不会为越界（out-of-bounds OOB）指针返回正确的元数据。因此，J＆K建议对指针算术运算进行检测，并在指针发生 OOB 时使其无效。任何后续间接引用都会触发故障，然后可以捕获该故障以输出警告。

​        但是，J＆K的方法破坏了许多使用 OOB指针执行计算的现有程序。有鉴于此，CRED通过跟踪OOB指针的引用信息来支持其创建和操作[37]。CRED 将 OOB 指针链接到所谓的 OOB objects，这些 OOB objects 存储每个OOB指针的原始引用地址。

​        Baggy Bounds Checking（BBC）通过将 OOB 指针与其引用对象之间的距离存储到指针的最大有效位[39]距离中，从而无需分配专用的 OOB 对象。标记最重要的位还会将 OOB 指针变成无效的用户空间指针，因此释放它们会导致错误。BBC 通过将所有分配大小四舍五入到最接近的二次方值来压缩每个对象元数据的大小，以便一个字节的元数据可以存储边界。

​        Low-fat pointer（LFP）边界检查器通过使分配大小可配置来改善BBC，这导致较低的性能和内存开销[42]，[43]。这个想法是将堆分成相等大小每个子堆仅支持一个分配大小。因此，可以通过查找该堆支持的分配大小来获取任何给定指针的分配大小。指针引用对象的基地址可以通过将其舍入为分配大小来计算。LFP 在处理 OOB 指针方面也不同于 BBC。为了与 uninstrumented libraries 更好地兼容，LFP 不会操纵指针表示来对 OOB 指针的引用进行编码。取而代之的是，只要将指针作为显式输入（例如，将指针作为自变量指定）或隐式（例如，从内存中加载的指针）作为函数的输入提供给函数，LFP 都会重新计算每个指针的引用。但是，这要求LFP强制执行不变式，即只要将指针作为其他函数的输入给出，这样在实际程序中好像太严格了（参阅8.1节）。

​        Per-object bounds trackers 可以支持接近完整的空间安全漏洞检测。但是，诸如 BBC 和 LFP 之类的技术确实舍弃了精度，以获得更好的运行时性能----因为它们舍入了分配大小并检查了分配范围而不是对象范围（参见VIII-B节）。

​        Per-object bounds trackers 还有其他缺点。首先，每个对象的边界跟踪器不会检测到对象内部的溢出（参阅8.2节）。其次，通过将指针指向OOB对象或将标记写入其高位标记为OOB可能会影响与未意识到程序中使用的边界检查方案的外部代码的兼容性。特别是，即使意识到了，外部代码也无法将 OOB 指针还原为内部普通入栈指针。

#### 4.1.2 违反时间内存安全 (Temporal Memory Safety Violations)：

**重用延迟 (Reuse Delay):**

​        基于位置的访问检查器可以通过替换为 red zones [27] – [29]， [31]，[34]或guard pages[32]，[ 33]，[35]，[36]来标记新近被释放的对象为非法的元数据。Identity-based checkers 可以用类似的方法使已释放对象的身份无效[55]。只要不重新使用已释放的内存或标识，现有的访问检查机制就可以检测到悬空的指针间接引用。当然如果程序为了重新分配重用了内存或标识，则这种方法将错误地允许悬空指针间接引用继续进行下去（？）。一些基于重用延迟的工具通过延迟内存区域或标识的重用，直到它们“老化” [27] – [29]， [31]，[34]，[55]，来减少此类检测失败的机会。由于较长的重用延迟会导致较高的内存开销，因此这会导致精度与内存开销之间的取舍，而且还会有更大的机会检测悬空指针的间接引用。

​        Dhurjati和Adve（D＆A）建议使用静态分析确定释放的内存何时可以安全重用[35]。D＆A在其自己的虚拟内存页面上分配每个内存对象，但是通过将虚拟内存页面别名到同一物理页面来允许对象共享物理内存页面。当程序释放内存对象时，D＆A会将其虚拟页面转换为 guard page。D＆A还利用称为 Automatic Pool Allocation 的静态分析，将堆划分为池[62]。这种分析可以推断何时不再可以访问池（即使是潜在的悬空指针），此时可以回收池中的所有虚拟页。党等 有人提出了一种不使用池分配的类似系统，因此可以将其应用于无源程序[36]。与D＆A类似，Dang等。在自己的虚拟页面上分配所有内存对象。释放对象后，Dang等人取消映射该对象的虚拟页面。这有效地实现了与保护页面相同的目标，但允许内核释放其用于虚拟页面的内部元数据，从而减少了物理内存开销。为了防止重用未映射的虚拟页面，Dang等人，建议在高地址位（即程序中使用的最高虚拟地址）处映射新页面。尽管这并不排除完全重用未映射的虚拟页面，但理论上在64位地址空间情况，不太可能发生重用。

**锁和密钥 (Lock-and-key)：**

​        基于身份的检查器可以通过为每个分配的内存对象分配唯一的分配标识符（通常称为密钥）并将此密钥存储在  lock location 来检测时间安全违规[46]，[47]，[ 56]。它们还为每个指针的元数据存储  lock location 和期望的密钥。当释放其关联对象时，检查器会从锁定位置撤消密钥。当程序间接引用其密钥与该指针的  lock location 中存储的密钥不匹配的指针时，锁定和密钥检查会检测到时间安全违规。假设使用唯一的密钥，此方法将完全涵盖临时安全违规行为[56]。由于此技术存储每个指针的元数据，它自然补充了使用 per-pointer bounds tracking 来检测空间违规的 identity-based checkers。 lock-and-key 检查器的缺点与 per-pointer bounds tracking 的缺点基本相同：与 uninstrumented code 的兼容性很差，因为 uninstrumented code 无法正确找到元数据；并且运行时开销很大，因为维护用于每个指针都很昂贵。

**悬空指针标记 (Dangling Pointer Tagging )**：

​        标记悬空指针的最直接方法是使调用 free() 函数的指针相关联的值和边界无效[49]。如果在以后的某个时间点间接引用这样的指针，则空间内存安全违规检测机制将触发警告。这种方法的缺点是它不标记悬挂指针的副本，后者以后也可以使用。

​        有几种工具不仅通过标记调用 free() 的指针，还通过维所有内存对象链接到引用它们的任何指针的辅助数据结构，来标记该指针的副本[57] – [60]。Undangle 使用污点跟踪[63]-[65]跟踪指针的创建，并维护对象到指针的映射[57]。

​        每当程序释放内存对象时，Undangle 都可以查询该指针映射，以快速找到指向当前已释放对象的所有悬空指针。Undangle旨在不仅报告使用情况，而且还报告悬挂指针的存在。它有一个可配置的时间窗口，其中它认为悬空指针是潜在的但并非不安全，例如，在嵌套对象释放期间出现的瞬时悬空指针。当此窗口到期时，或更早在程序尝试间接引用该指针时，Undangle报告悬空的指针。

​        DangNull [58]，FreeSentry [59]和DangSan [60]在编译时避开了污点跟踪和工具指针的创建。只要程序分配了指针，这些工具就会通过调用一个称作运行时注册的函数来维护指针映射。每当程序释放内存对象时，工具都会查找所有指向要释放对象的指针，并使它们无效。无效的悬挂指针的后续间接引用会导致硬件陷阱。

​        不基于污点跟踪的悬空指针标记工具具有一些基本限制。首先，它们需要源代码？的可用性，因为源依赖精确的类型信息来确定哪些操作存储新的指针。其次，如果程序以类型不安全的方式（例如，通过将其强制转换为整数）复制指针，则它们将无法维护准确的元数据。第三，也是最重要的是，它们只能将对象链接到存储在内存中的指针，因此不知道存储在寄存器中的指针悬空。基于污点跟踪的工具（例如Undangle）没有这些缺点，但是会带来明显的性能和内存开销。

### 4.2 使用未初始化的变量 (Use of Uninitialized Variables)

​        下述工具检测未初始化值的使用。

**未初始化的内存读取检测 (Uninitialized Memory Read Detection)**：

​        通过将新分配对象占用的所有存储区域标记为在元数据存储中未初始化[27]，基于位置的访问检查器可以扩展为检测未初始化的内存读行为。这些工具如果发现未初始化的存储区域读行为，会读取指令以发出警告，并通过写入来清除覆盖区域的未初始化标记。需要注意的是标记存储区域为未初始化并不等同于将它们标记 red zones，因为 red zones 的读和写访问都会触发警报，而访问未初始化的内存有读行为会触发警告。

**未初始化值使用检测 (Uninitialized Value Use Detection)**：

​        检测未初始化内存的读取会产生许多误报检测，因为C ++ 14标准明确允许未初始化值在不使用的情况下在程序中传递。例如，将部分未初始化的结构从一个位置复制到另一个位置时，就会发生这种情况。Memcheck 尝试通过将错误报告限制为四种情况来检测未初始化值的使用：（i）对（部分）未定义的指针的间接引用；（ii）在（部分）未定义的值上分支(branching)；（iii）将未定义的值传递给系统调用； （iv）将未初始化的值复制到浮点寄存器[28]。为了支持该策略，Memcheck 为程序存储器中的每个部分初始化的字节添加了一个影子状态字节。这使Memcheck能够以位级精度跟踪程序所有内存的定义。Memcheck 近似于C ++14语义，但是会产生假阴性（未能报告未初始化内存的非法使用）和假阳性（报告未初始化内存的合法使用），鉴于Memcheck 在二进制级别而非源代码级别运行，因此这是不可避免的。MemorySanitizer （MSan）基本上执行与Memcheck相同的策略，但是在编译器的中间表示（IR）级别上对程序进行检测[66]。IR代码比二进制代码携带更多的信息，这使得 MSan 比 Memcheck 更精确。MSan不会产生误报（前提是已检测到整个程序）并且几乎不会产生误报。它的性能开销也比Memcheck低一个数量级。

### 4.3 指针类型错误 ( Pointer Type Errors)

​        这些工具检测不兼容类型的指针的类型错误转化和间接引用。

**指针转换监视器 (Pointer Casting Monitor)**：

​        ointer casting monitors 通过 C++ static_cast 运算符检测非法向下转换。当强制转换的目标类型与源对象的运行时类型（或其祖先类型之一）不相等时，将发生非法向下转换。 UndefinedBehaviorSanitizer [67]（UBSan）和Clang CFI [68]包含检查器，这些检查器通过将目标类型与与源对象关联的运行时类型信息（RTTI）进行比较来验证 static_cast 操作的正确性。这有效地将 static_cast 操作转换为 dynamic_cast 。缺点是基于 RTTI 的工具无法验证之间的强制转换缺少 RTTI 的非多态类型。

​        CaVer [69] 和 TypeSan [70] 不依赖 RTTI 来跟踪类型信息，而是维护程序中使用的所有类型和所有对象的元数据。这样，他们可以将类型检查的范围扩展到非多态类型。在编译时，这些工具将构建每个类类型的元数据表，其中包含给定指针类型的所有有效类型强制转换。类型表对类继承和组成关系进行编码。这两个工具还通过监视内存分配并将分配的类型存储在元数据存储中，来跟踪每个活动对象的有效运行时类型。为了执行向下检查，这些工具将检索运行时从元数据存储中获取源对象的类型，然后在类型表中查询相应的类，以检查类型转换是否在表中（因此是允许的）。 HexType 类似地在不连续的元数据结构中跟踪类型信息，但是提供了更准确的运行时类型跟踪[71]。 HexType 还用其自己的优化实现替换了 dynamic_cast 的默认实现，同时保留了其运行时语义，即对于失败的强制转换返回 NULL。

**指针使用监视器 (Pointer Use Monitor)**：

​         C / C ++支持多种以潜在危险的方式转换指针类型构造。C风格的强制转换、reinterpret_cast 和 union 合都可以用来绕过编译时和运行时类型检查。但是，将指针强制转换监视扩展到这些构造可能会导致误报。这是因为程序员可以在语言标准允许的范围内合法使用此类构造它。因此，与指针转换监视相比，可能会选择指针间接引用/使用监视。

​        Loginov 等人提出了用于C程序的指针使用监视器[72]。该工具通过监视 load 和store 操作来维护和验证每个内存位置的运行时类型标签。标签包含最后用于写入其相应存储位置的标量类型。聚合类型通过分解为标量组件来提供支持。该工具将标签存储在影子存储器中。每当从内存中读取值时，该工具都会检查用于加载值的类型是否与type标签匹配。

​        LLVM Type Sanitizer（TySan）还在影子存储器中维护类型标签存储，并验证加载指令的正确性[73]。但是，与 Loginov 等人的工具相反，TySan 不需要用于存储和从内存位置加载的类型完全匹配。相反，TySan仅需要类型兼容性，这由C / C ++标准中的别名规则定义。TySan利用了由编译器前端（Clang）生成的元数据，该元数据包含类型之间的别名关系。该元数据在运行时用于，例如，即使通过使用指向较大类型的指针存储目标位置，也可以通过字符指针类型进行所有加载。Loginov 等人的工具会将其检测为错误，但是语言标准明确允许这种行为。

​         EffectiveSan 是另一个指针使用监视器，它执行类型检查以及指针使用时的边界检查[74]。EffectiveSan 对每个分配站点进行检测，以使用其静态确定的类型标记每个分配的对象。它将声明的变量类型用于堆栈和全局变量，以及使用 C++ new 运算符分配的对象。对于使用 malloc 分配的对象，它使用对象的第一个左值用法的类型。EffectiveSan 还在编译时生成类型布局元数据，其中包含每种类型的所有嵌套子对象的布局信息。在每个指针间接引用时，都使用对象类型标记结合类型布局元数据来检查类型兼容性和对象边界。EffectiveSan 的边界检查支持通过使用类型布局信息在运行时导出子对象边界来检测对象内溢出。

​        几种工具还可以检测间接函数调用中的指针类型错误，即通过与被调用函数的[67]，[68]，[75]类型不兼容的指针来调用函数。基于功能签名的前沿控制流完整性机制，例如 Clang CFI [68]，可以看作是检测此类功能指针误用的消毒程序。由于所有函数签名在编译时都是已知的，因此这些工具可以检测指针类型和函数类型之间的不匹配，而无需维护运行时标记。

### 4.4 可变参数功能误用 (Variadic Function Misuse)

​        这些工具检测违反内存安全性的行为，未初始化的变量使用特定于可变参数的函数。

**危险的格式字符串检测(Dangerous Format String Detection)**：

​        最常见的可变参数函数滥用错误类别是格式字符串漏洞。因此，大多数工作仅专注于检测对 printf（） 的不安全调用。在这些工作中，有一些工具可以限制在格式字符串[76]，[77]中使用 ％ n限定符。该限定符可用于使 printf（） 写入内存中调用者指定的位置。但是，此危险操作[2]专门用于 printf（） 函数，因此上述工具的适用性受到限制。

**参数不匹配检测（Argument Mismatch Detection）：**

​        FormatGuard 防止 printf（）  读取比调用者传递的参数更多的参数[78]。FormatGuard通过将调用重定向到受保护的printf 实现来实现，该实现每次通过 va_arg  检索可变参数时都会递增计数器。如果计数器超过了在调用处指定的参数数量，则 FormatGuard 会发出警报。HexVASAN 将参数计数推广到所有可变参数函数，并且还添加了类型检查[79]。HexVASAN对可变参数函数的调用站点进行检测，以捕获传递给被调用方的参数的数量和类型，并将此信息保存在元数据存储中。然后，该工具会检测 va_start 和 va_copy 操作从元数据存储中检索信息，并且它对 va_arg 操作进行检测，以检查所访问的参数是否在给定数量的参数和给定类型内。

### 4.5 其他漏洞

这些工具可以检测其他未定义的行为或定义良好但潜在的意外和危险行为。

**无状态监视 (Stateless Monitoring)**：

UndefinedBehaviorSanitizer（UB-San）是一种动态工具，可检测到我们目前尚未介绍的未定义行为[67]。UBSan 当前检测到的未定义行为包括有符号整数溢出、浮点数或整数被零除、无效的按位移位运算、由强制转换引起的浮动点溢出（例如，将大的双精度浮动点数强制转换为单精度变量）、使用未对齐的指针、执行使指针溢出的算术运算、间接引用空指针、带返回值函数分支尾部不返回值。UBSan的大多数检测功能都是无状态的，因此可以集体打开它们而不会互相干扰。 UBSan 还可以检测到几种定义良好但很可能出乎意料的行为。例如，语言标准规定无符号整数溢出时会回绕。这种定义良好的行为通常是出乎意料的，并且经常是错误的来源，因此 UBSan 可以选择检测这些无符号整数环绕。

## 5. PROGRAM INSTRUMENTATION

​        消毒程序通过将内联引用监视器（IRM）嵌入到程序中来实现其错误查找策略。这些 IRM 监视和调解可能导致漏洞的所有程序指令。这样的指令包括（但不限于）内存 load 和 store、stack frame (de) allocations、对内存分配函数的调用（例如 malloc ）、系统调用。可以使用编译器，链接器或检测框架来嵌入IRM。

### 5.1 源码层次检测 (Language-level Instrumentation)

​        可以将消毒程序嵌入源代码或抽象语法树（AST）级别。源代码和AST是特定于语言的，通常包含完整的类型信息、语言的特定语法、编译时间评估的表达式，例如 const_cast 和 static_cast 类型转换。语言特定信息通常在 AST 转化为更为底层的 IR 层次时被丢弃。对于通过指针转换监视来检测指针类型错误的消毒程序，建议（甚至是必要）使用语言级别的检测。

​        在语言级别进行检测的另一个优点是，编译器在整个编译的早期阶段都保留了程序的完整语义。因此，清理程序可以看到程序员打算使用的语义。在编译的后期阶段，编译器可以假定程序不包含未定义的行为，并且可以基于此假设优化代码（例如，通过消除看似不必要的安全检查）。在语言级别进行检测的缺点是应用程序的整个源代码必须可用，并且代码必须以预期的语言编写。因此，该方法不适用于链接到闭源库的应用程序，也不适用于包含内联汇编代码的应用程序[80]。

### 5.2 IR层次检测 (IR-level Instrumentation)

​        当 AST 被转化为更为底层的 IR 代码中时，消毒程序也可以嵌入到后期编译中。诸如 LLVM 之类的编译器后端支持 IR 层次的检测[81]。这种方法比源代码级转换更通用，因为编译器 IR （通常）独立于源语言。因此，通过在此级别进行检测，消毒程序可以自动支持多种源语言。另一个优点是，编译器后端实现了可以由消毒程序使用的各种静态分析和优化过程。消毒程序可以利用此基础结构来优化它们嵌入到程序中的IRM（例如，通过删除冗余或可证明安全的检查）。

​        IR级别仪器的缺点与语言级别仪器的缺点在很大程度上相似，即缺乏对闭源库和内联汇编代码的支持（第5.1节）。例外地，AddressSanitizer（ASan）确实通过检测内联汇编块中的 MOV 和 MOVAPS 指令，为内联x86汇编代码提供了有限的支持[31]。但是，这种方法是特定于体系结构的，需要针对每个受支持的体系结构重新实现或复制。

### 5.3 二进制检测 (Binary Instrumentation)

​        动态二进制翻译（DBT）框架允许在运行时对程序进行检测[82]-[84]。他们读取程序代码，对其进行检测，然后在程序执行时将其翻译为机器代码，并暴露各种影响执行的钩子（hooks）。编译器为基础的基于DBT的工具的主要优点是他们在闭源程序上表现不错。此外，DBT框架无论源码是啥，都提供了对用户模式代码的完整检测覆盖。DBT框架可以检测程序本身、第三方代码（可以动态加载）、甚至动态生成的代码。

​        与静态仪器工具相比，DBT 的主要缺点是运行时性能开销高得多（参阅第8.5节）。该开销可以主要归因于运行时指令的解码和翻译。通过使用静态二进制检测（SBI）框架对二进制文件进行静态检测，可以部分解决此问题。但是，基于  SBI 和 DBT 的消毒程序都必须操作实际中不包含类型信息或特定语言文法的二进制文件。因此，在此阶段无法嵌入指针类型错误的消毒程序。关于堆栈帧和全局数据节布局的信息也在二进制级别丢失，这使得使用二进制检测时无法插入完全精确的空间内存安全消毒程序。

### 5.4 库检测 (Library Interposition)

​        尽管非常粗糙，有一种使用库插件（interposer）拦截对库函数的调用的方法[85]。库插件是一个共享库，当将其预加载到程序中时[86]，它可以拦截、监视和操纵程序中的所有库间函数调用。一些消毒程序使用此方法来拦截对内存分配函数（例如 malloc 和 free ）的调用。

​        这种方法的优点是，与基于 DBT 的工具类似，它对于 COTS 二进制文件也很有效，而不需要源代码或目标代码。但是，与 DBT 相反，库插入几乎不会产生任何开销。缺点之一是，库插入仅适用于库间调用。同一库中两个函数之间的调用不能被拦截。另一个缺点是库插入是高度平台化和特定于目标的。例如，使用库插入来拦截对 malloc 的调用的消毒程序不适用于具有自己的内存分配器的程序。

## VI. META DATA MANAGEMENT



## VII.  RIVING A SANITIZER



## VIII. ANALYSIS



## IX. DEPLOYMENT



## X. FUTURE RESEARCH AND DEVELOPMENT DIRECTIONS

