# 2019 IEEE Symposium on Security and Privacy

# SoK: Sanitizing for Security

<p align="center">
    Dokyung Song, Julian Lettner, Prabhu Rajasekaran,<br/>
    Yeoul Na, Stijn Volckaert, Per Larsen, Michael Franz<br/>
    University of California, Irvine<br/>
    {dokyungs,jlettner,rajasekp,yeouln,stijnv,perl,franz}@uci.edu
</p>


[TOC]



## 摘要

​	众所周知，C和C ++编程语言是不安全的，但仍然是必不可少的。因此，开发人员会采取多管齐下的方法来解决对手面前的安全问题。这些包括手动，静态和动态程序分析。动态错误查找工具（以下称为 “ sanitizers”）可以查找其他类型的分析错误，因为它们会观察程序的实际执行情况，因此可以在发生错误时直接观察错误的程序行为。

​	大量的 sanitizers已由学术界原型化，并由从业人员完善。我们提供了 sanitizers的系统概述，重点是 sanitizers在发现安全问题中的作用。具体来说，我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。

## 1、INTRODUCTION

​        C和C ++仍然是底层系统软件（例如，操作系统内核，运行时库和浏览器）的选择语言。关键原因在于它们高效且使程序员可以完全控制底层硬件。但另一方面，程序员必须确保每个内存访问都是有效的，没有计算会导致未定义的行为，等等。在实践中，程序员通常没有履行这些职责，并引入了使代码容易受到利用(容易发生漏洞并被利用这些漏洞)的错误。

​       同时，绕过(错开了)诸如地址空间布局随机化（ASLR）和数据执行保护（DEP）之类广泛采用的缓解措施，内存破坏漏洞的利用也越来越复杂[1] – [4]。代码重用攻击（例如，面向返回的编程（ROP））破坏了控制方面的数据（如函数指针或返回地址），从而劫持了程序的控制流 [1]。纯数据攻击(例如面向数据的编程（DOP）)利用 可以在合法控制流路径上调用的 指令，并通过仅破坏程序的非控制数据 来破坏程序[4]。

​        作为针对错误的第一道防线，程序员在将软件部署到生产环境之前，会使用分析工具来识别安全问题。这些工具依赖于静态程序分析、动态程序分析或静态与动态程序分析相组合。静态工具分析程序源代码，并**产生对于所有可能的代码执行都保守地正确的结果**[5] – [9]。相反，动态错误查找工具（通常称为“ sanitizers”）分析单个程序执行并**输出仅对单个运行有效的精确分析结果**。

​         sanitizers现已得到广泛使用，并负责发现许多漏洞。但是，尽管它们在发现漏洞中无处不在且起着关键作用，但 sanitizers通常并没有被很好地理解，这阻碍了它们的进一步发展和采用。实际上，尽管该领域有大量研究工作，但只有少数研究得到采用，从而使许多类型的漏洞都没有得到解决。本文提供了 sanitizers的系统概述，重点是 sanitizers在发现安全漏洞中的作用。我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。根据我们的发现，我们对开发人员的发展或研究方向提出以下三个目标（i）找到现有工具所检查不到的漏洞，（ii）改善实际中程序的兼容性（iii）更高效地找到漏洞的方法。

​        本文的其余部分安排如下：我们从对 sanitizers和漏洞缓解措施两者间高层次表现比较开始（第2节）。接下来，我们描述C / C ++中的低层次漏洞（第3节）和分类技术以检测它们（第4节）。然后，我们继续介绍 sanitizers的两种关键实现方法：程序检测技术（第5节）和元数据管理（第6节）。然后，我们简要讨论如何用 sanitizers方式去驱动一个程序，以及如何最大化地发挥 sanitizers的功效（第七节）。接下来，我们将介绍正在积极维护种 或在学术会议上发布过的 sanitizers的一个汇总，重点是其精度，兼容性和性能/内存成本（第八节）。我们还将调查这些工具的部署情况（第IX节）。我们以研究方向的未来展望作为论文的结尾（第十节）。

## 2、EXPLOIT MITIGATIONS VS. SANITIZERS

​         sanitizers在许多方面类似于许多众所周知的漏洞利用缓解措施，它们可以以类似的方式来检测程序，例如，通过插入嵌入式参考监视器（IRM）。尽管有这些相似之处，但缓解利用漏洞措施和 sanitizers的目标和用例却大不相同。我们在表I中总结了主要差异。

<p align="center">表1 Exploit mitigations VS Sanitizers</p>

|                    | 漏洞利用缓解措施 | sanitizers |
| ------------------ | ---------------- | ---------- |
| 目标               | 缓解攻击         | 查找漏洞   |
| 应用场景           | 生产             | 预发行     |
| 绩效预算           | 非常有限         | 高得多     |
| 违规结果           | 程序终止         | 问题诊断   |
| 在错误位置触发违规 | 有时             | 总是       |
| FPs公差            | 零               | 更高一点   |
| 残差良性错误的结果 | 期望的           | 不想要的   |

​        两种工具之间的最大区别在于它们执行的安全策略的类型。利用缓解措施部署旨在检测或预防攻击的策略，而 sanitizers则旨在查明错误的程序语句的确切位置。控制流完整性（CFI）[10]，[11]，数据流完整性（DFI）[12]和写完整性测试（WIT）[13]是缓解漏洞的示例，因为它们检测到与合规的控制流或数据流路径之间的偏差，这通常是由于漏洞的利用而发生的，但不一定非得发生在易受攻击的程序语句的确切位置。相反，可以将边界检查工具视为 sanitizers，因为违反其策略的行为直接在易受攻击的语句位置触发。

​        一些工具有选择地应用消毒技术，可能还结合了漏洞利用缓解措施的技术。例如，代码指针完整性（CPI）仅在程序直接或间接访问敏感代码指针时才执行边界检查（许多 sanitizers中使用的一种 sanitizers技术）[14]。因此，我们将CPI视为一种漏洞利用缓解措施的方法，而不是一种 sanitizers，因为CPI仅检测可以使用边界检查检测到的所有错误的一小部分。

​        漏洞利用缓解措施的目的是在生产中部署，因此对各个设计方面提出了严格的要求。首先，漏洞利用缓解措施如果导致不可忽略的运行时间开销，则很少能被实际采用[15]。 sanitizers对性能的要求不那么严格，因为它们仅用于测试。第二，漏洞利用缓解措施中的误报检测是不可接受的（也就是对容错性要求较高），因为它们会终止程序。而如果开发人员本意是查看错误报告（报错日志），则 sanitizers可以容忍错误的警报。最后，出于可靠性和可用性的原因，在生产系统中允许存在残差的良性错误（例如，写入填充），并且经常会希望这种良性错误；而 sanitizers的目的是精确地检测这些错误，因为它们的可利用性（就是程序到底会不会执行到这一段代码）未知。

## 3. LOW - LEVEL VULNERABILITIES

​        鉴于与安全性相关的漏洞种类繁多，我们将重点介绍在C / C ++中具有特定安全性的漏洞。这不仅包括未定义的行为，还包括在缺乏类型和内存安全性的情况下可能具有潜在危险的定义良好的行为。我们简述这些错误以及如何利用它们来泄漏信息、提升特权或执行任意代码。

### 3.1 违反内存安全(Memory Safety Violations)

​        如果程序中的指针仅访问其  intended referents，而这些预期的引用是有效的，则该程序是 memory safe 。指针的预期对象是从其基址派生指针的对象。根据引用对象的类型，它在其分配和释放之间（对于堆分配的引用对象）、在函数调用与其返回（对于堆栈分配的引用对象）之间，在其关联线程的创建和销毁之间都是有效的（对于线程本地引用）或无期限的（对于全局引用）。

​        违反内存安全性是最严重的安全漏洞之一，并且在文献[15]，[16]中进行了广泛的研究。他们的利用可能导致代码注入[17]，控制流劫持[1]，[18]，[19]，特权升级[20]，信息泄漏[21]和程序崩溃。

#### 3.1.1 空间安全违规 ( Spatial Safety Violations)：

​        访问不（完全）在指针的预期引用范围之内的内存构成空间安全违规。缓冲区溢出是违反空间安全性的典型示例。当程序超出缓冲区末尾写入时，将发生缓冲区溢出。如果易受攻击的访问的目标对象是一个子对象（例如，结构字段），并且如果攻击者在同一对象内写入另一个子对象，则我们将其称为  intra-object overflow 。清单1显示了一个对象内溢出漏洞，可以利用该漏洞执行特权升级攻击。

<p align="center">清单1. 对象内溢出漏洞，可以利用该漏洞重写对安全敏感的、非控制数据</p>

```c
struct A { char name[7]; bool isAdmin; };
struct A a; char buf[8];
memcpy(/* dst */ a.name, /* src */ buf, sizeof(buf));
```

#### 3.1.2 违反时间安全性(Temporal Safety Violations)：

当程序访问不再有效的引用时，发生违反时间安全性的行为。当一个对象变为无效时（通常是通过显式地对其进行分配），指向该对象的所有指针都将变为 dangling 。通过悬空指针访问对象被称为  use-after-free。访问的其范围或在函数返回之后本地对象外分别被称为  use-after-scope 和 use-after-return 。当攻击者可以重用和控制释放的区域时，这种类型的漏洞就可以被利用，如清单2所示。

<p align="center">清单2. Use-after-free 的漏洞，可以被利用来劫持程序的控制流</p>

```c
struct A { void (*func)(void); };
struct A *p = (struct A *)malloc(sizeof(struct A));
free(p); // Pointer becomes dangling
...
p->func(); // Use-after-free
```

### 3.2 使用未初始化的变量(Use of Uninitialized Variables)

​        变量在初始化之前具有  indeterminate value [22]，[23]。如果源变量和目标变量都具有无符号的窄字符类型，则C++14允许将此不确定值赋给其他变量。任何未初始化变量的使用都会导致未定义的行为。这种不确定行为的影响取决于许多因素，包括用于编译程序的编译器和编译器标志。在大多数情况下，不确定值实际上是先前释放的变量的（部分）内容，这些变量所占用的内存位置与未初始化的变量相同。由于这些先前释放的变量有时可能对安全性敏感值，未初始化的内存的读取可能是信息泄漏攻击的一部分，如清单3所示。

<p align="center">清单3.使用部分初始化的变量，该变量在未初始化的值越过可信任边界时会变得易受攻击</p>

```c
struct A { int data[2]; };
struct A *p = (struct A *)malloc(sizeof(struct A));
p->data[0] = 0; // Partial initialization
send_to_untrusted_client(p, sizeof(struct A));
```

### 3.3 指针类型错误（Pointer Type Errors）

​        C 和 C ++ 支持多种强制转换运算符和语言构造，这些构造运算符和语言构造可能导致内存访问错误地解释了其引用对象中存储的数据，从而违反了类型安全性。指针类型错误通常是由不安全的强制转换引起的。C 允许在指针类型之间进行所有类型转换，包括在整数和指针类型之间进行类型转换。同样，C++ reinterpret_cast 类型转换运算符不受任何限制。而 static_cast 和 dynamic_cast 的操作有所限制限制。static_cast 禁止指向整数强制转换的指针，以及禁止指向与继承无关的对象的指针之间的强制转换。但是，它的确允许将指针从基类强制转换为派生类（也称为downcasting ），以及从void 类型进行的所有强制转换。当向下转换的指针既没有其引用对象的运行时的类型，也没有引用对象的祖先类型之一时，就会发生 bad-casting（通常称为 type confusion）。

<p align="center">清单4. 错误转换漏洞导致类型和内存不安全的内存访问</p>

```c
class Base { virtual void func(); };
class Derived : public Base { public: int extra; };
Base b[2];
Derived * d = static_cast<Derived * >(&b[0]); // Bad-casting
d->extra = ...; // Type-unsafe, out-of-bounds access, which
                // overwrites the vtable pointer of b[1]
```

​        为了安全地向下转换，程序员必须使用 dynamic_cast 运算符，该运算符执行运行时类型检查，如果检查失败，则返回空指针。但是，使用 dynamic_cast 完全是可选的（非必需的），并且会带来额外的运行时开销。

​        在函数指针类型之间进行转换时，也会发生类型错误。同样，C ++ 的 reinterpret_cast 和 C 对不兼容的函数指针类型之间的强制转换没有任何限制。如果通过错误类型的函数指针间接调用函数，则目标函数可能会错误地编译(误解)其参数，从而导致更多类型错误。最后，C 还允许通过 union 类型进行类型修剪。如果程序通过转换实际存储数据的成员对象到不同的其他类型成员对象的方式去读取 union，则可能会误解底层的内存内容。此外，如果用于读取的成员对象大于用于存储数据的成员对象，则从 union 中读取的高位字节将采用未指定的值。

### 3.4 可变参数功能滥用 ( Variadic Function Misuse)

​    C / C ++支持  variadic functions，除了固定数量的常规函数参数外，它们还接受可变数量的可变长函数参数。可变参数函数的源代码未指定这些可变参数的数量或类型。相反，固定参数和函数语义对可变参数的预期数量和类型进行编码。可变参数可以使用 va_arg 进行访问并同时进行类型转换。通常，不可能静态验证 va_arg 访问有效参数，或将参数转换为有效类型。缺少静态验证会导致类型错误，违反空间内存安全性以及使用未初始化的值。

<p align="center">清单5. CVE-2012-0809的 简化版本；用户提供的输入<br>被误用作传递给类似 printf() 的较大格式字符串的一部分</p>

```c
char * fmt2; // User-controlled format string
sprintf(fmt2, user_input, ...);
// prints attacker-chosen stack contents if fmt2 contains
// too many format specifiers
// or overwrites memory if fmt2 contains %n
printf(fmt2, ...);
```

### 3.5 其他漏洞 (Other Vulnerabilities)

​        在没有类型和内存安全性的情况下，还有其他操作可能会带来安全风险。值得注意的例子包括溢出错误，当在内存分配或指针算术运算中使用此类值时，可能会利用这些错误。如果使用攻击者控制的整数值来计算缓冲区大小或数组索引，则攻击者可能使该值溢出以分配比预期小的缓冲区（如清单6所示），或者绕过现有的数组索引检查，从而触发一个出界外的访问。

<p align="center">清单6. CVE-2017-5029的简化版本；有符号整数溢出漏洞，<br>可能导致违反空间内存安全性</p>

```c
// newsize can overflow depending on len
int newsize = oldsize + len + 100;
newsize * = 2;
// The new buffer may be smaller than len
buf = xmlRealloc(buf, newsize);
memcpy(buf + oldsize, string, len); // Out-of-bounds access
```

​        C / C ++并未定义有符号整数溢出的结果，但规定无符号整数溢出时会回绕。但是，这种环绕行为通常是意料之外的，并且有潜在的危险。

​        启用编译器优化后，未定义的行为（例如，有符号整数溢出）会带来额外的安全风险。在存在潜在未定义行为的情况下，编译器被默认允许假定程序将永远不会达到触发此未定义行为的条件。而且，编译器可以基于此假设[24]执行进一步的优化。因此，编译器不必静态验证程序是否没有潜在的未定义行为，并且编译器没有义务生成能够识别或减少未定义行为的代码。这个基本原理的问题在于，基于程序没有未定义行为的假设进行的优化有时会导致编译器忽略安全检查。例如在CVE-2009-1897中，海湾合作委员会臭名昭著地省略了Linux内核驱动程序之一中的空指针检查，这导致了提权漏洞[25]。编译器开发人员会定期向其编译器中添加此类积极的优化。因此，有些人将未定义的行为称为 time bombs [26]。

<p align="center">清单7. CVE-2009-1897的简化版本；取消引用指针<br>可使编译器安全地假定指针为非null</p>

```c
struct sock *sk = tun->sk; // Compiler assumes tun is not 
                           // a null pointer
if (!tun) // Check is optimized out
    return POLLERR;
```

## 4. BUG FINDING TECHNIQUES

​        现在，我们回顾相关的错误查找技术。我们在每个小节中都以对错误发现策略的非正式描述开头，然后对实现（或近似）该策略的机制进行描述。

### 4.1 违反内存安全 (Memory Safety Violations)

​        内存安全错误查找工具会检测未针对其预期目标（即，违反空间安全）或针对不再有效的目标（即，违反时间安全）的指针的间接引用。有两种检测这些错误的工具。我们在这里总结了它们的高级目标和属性，然后深入讨论了这些工具可用来检测内存安全错误的技术。

**基于位置的访问检查器 (Location-based Access Checkers)：**

​        基于位置的访问检查器检测内存访问无效的内存区域。这些检查器具有一个元数据存储，该存储可维护每个字节（一部分）可寻址地址空间中的状态，并且每当程序尝试访问内存以确定内存访问是否有效时，都应查阅该元数据存储。基于位置的访问检查器可以使用 red zones插入 [27] – [31]或保护页[32]，[33]来检测空间安全违规情况。这些技术中的任何一种都可以与重用延迟结合使用，以另外检测时间安全性违规 [27]-[29]， [31]-[36]。 基于位置的访问检查器的费用较低运行时性能开销，并且与非仪表代码（uninstrumented code）高度兼容。缺点是这些工具不精确，因为它们只能检测指令是否访问有效内存，而*不能检测访问的内存是否是指令的预期对象的一部分( not if the accessed memory is part of the intended referent of the instruction)*。这些(?)工具通常会导致高内存开销。

**基于身份的访问检查器（Identity-based Access Checkers):**

​        基于身份的访问检查器检测与预期引用对象不匹配的内存地址访问。这些工具为每个分配的内存对象维护元数据（例如，边界或分配状态），并且具有适当的机制来确定程序中每个指针间接引用以确定该引用是否访问该指针的预期引用时，会发生元数据查找。基于身份的访问检查器可以使用按对象边界跟踪[34]， [37]-[43]或按指针边界跟踪[44] – [55] 可以检测到违反空间安全的行为，并且可以通过重用延迟[55]，锁定和钥匙检查[46]，[47]，[56]或悬置指针标记[57] – [60] 进行扩展。检测临时安全违规。基于身份的检查器比基于位置的访问检查器更为精确，因为它们不仅可以检测到对无效内存的访问，而且还可以检测对预期对象以外的有效内存的访问。但是，与基于位置的检查器相比，这些工具确实会带来更高的运行时性能开销。基于身份的检查器通常与非仪表代码不兼容。他们的假阳性检出率也比基于位置的检查器。

#### 4.1.1 违反空间内存安全 (Spatial Memory Safety Violations)：

**红色区域插入 (Red-zone Insertion)**：

​        基于位置的访问检查器可以在内存对象 [27] – [31]之间插入所谓的  red-zones。这些 red-zones 表示内存访问越界，并在元数据存储中标记为无效内存。对 red-zones 或未分配的内存区域的任何访问都会触发警告。Purify 是采用该技术的第一个工具[27]。Purify 在每个分配的开始和结束插入 red zones。Purify使用大型影子内存位图跟踪程序分配的地址空间的状态，该位图在每个字节的内存中存储两位状态。Valgrind 的 Memcheck 使用相同的技术，但为内存的每一位保留两位状态[28]。因此，Memcheck 能够以字级精度而不是字节级精度检测访问错误。

​        轻量级边界检查（LBC）同样会插入 red zones，但为基于位置的访问检查添加了一条快速路径，以减少元数据查找的开销[30]。LBC 通过用随机模式填充 red zones 来做到这一点，并将每个内存访问读取/覆盖的数据与填充模式进行比较。如果数据与填充模式不匹配，则认为该访问是安全的，因为它不可能被标记为 red zones。如果数据确实符合填充模式，则 LBC 将执行辅助慢路径检查，以查找元数据存储中已访问数据的状态，并在已访问数据为 red zones 时触发警告。

​        使用红区插入的基于位置的访问检查器通常会产生较低的运行时性能开销，但精度有限，因为它们只能检测到针对红区的非法访问。以有效对象为目标的非法访问是无法检测到，因为该对象与预期的对象可能同为某一分配的一部分，也可能不是的。基于 red zones 插入的工具也无法检测对象内部的溢出错误，因为它们没有在子对象之间插入 red zones。在技术上可行时，插入子对象间的 red zones 时会导致过多的内存开销，并且会更改父对象的布局。因此，必须修改访问父对象或其子对象之一的任何代码，这也将破坏未意识到数据布局已更改的外部代码的兼容性。

**保护页面 (Guard Pages)**：

​        基于位置的访问检查器可以在每个分配的内存对象[32]-[33]之前和(或)之后插入不可访问的保护页面。访问保护页的越界读取和写入会触发页面错误，这又会触发应用程序中的异常。使用分页硬件检测非法访问允许基于位置无需检查单个 load 和 store 指令即可访问检查程序。但是，使用保护页确实会导致高内存开销，从而使该技术对于具有较大工作集的程序不切实际。Microsoft 意识到了这个问题，并在 PageHeap [33]中添加了一个选项，使内存对象带有保护块而不是完整的保护页。PageHeap 使用填充模式填充这些保护块，并保证释放内存对象时该模式仍然存在。此技术严格不如红区插入，因为它仅检测越界写入(而不读取)，并且除非要写入的对象被释放，否则不会检测到非法写入。

**每个指针的边界跟踪(Per-pointer Bounds Tracking)：**

​        基于身份的访问检查器可以存储每个指针的边界元数据[44]-[55]。每当程序通过调用 malloc 或通过获取对象的地址创建指针时，跟踪器都会为新指针将其引用对象的基址和空间大小存进元数据。当程序通过算术和赋值运算计算新的指针时，跟踪器将传播(propagates)此元数据。通过检测所有指针间接引用并检查指针在简介引用时是否在其关联边界之外，可以检测到空间内存安全冲突。

​        使用基于指针的边界跟踪的基于身份的访问检查器可以提供完整的空间内存冲突检测，包括检测对象内溢出。每当程序从子对象的地址（即结构域）派生指针时，SoftBound [48]和 Intel Pointer Checker [49] 通过将指针范围缩小到子对象的边界来检测对象内溢出。每指针边界跟踪的主要缺点是兼容性差，因为该程序通常无法将指针传递给未插入库，因为此类库无法正确传播或更新边界信息。另一个缺点是每个指针元数据传播会增加运行时的开销。CCured 通过标识“安全”指针来减少这种开销，可以将其从边界检查和元数据传播中排除[50]。然而，即使有了这种优化，没有硬件支持，每个指针的边界检查仍然很昂贵。

**每个对象的边界跟踪(Per-object Bounds Tracking)**：

​        基于身份的访问检查器还可以存储每个内存对象的边界元数据，而不是每个指针的边界元数据[34]， [37] – [43]。

​        这种方法是由 Jones 和 Kelly（下称：“J＆K”）率先提出的，解决了一些与每指针边界跟踪有关的兼容性问题[34]。Per-object Bounds Tracking 可以维护边界元数据，而无需检测指针的创建和分配操作。跟踪器仅需要拦截对内存分配（即 malloc ）和释放（ 即free ）函数的调用，即使在未完全检测的程序中也可以实现。由于边界元数据仅为对象而不是指针维护，因此很难将指针链接到其预期的引用对象。虽然内部指针类型的预期引用对象可以使用基于（生命周期）范围的查找，来在元数据中的存储，但这样的查找将不会为越界（out-of-bounds OOB）指针返回正确的元数据。因此，J＆K建议对指针算术运算进行检测，并在指针发生 OOB 时使其无效。任何后续间接引用都会触发故障，然后可以捕获该故障以输出警告。

​        但是，J＆K的方法破坏了许多使用 OOB指针执行计算的现有程序。有鉴于此，CRED通过跟踪OOB指针的引用信息来支持其创建和操作[37]。CRED 将 OOB 指针链接到所谓的 OOB objects，这些 OOB objects 存储每个OOB指针的原始引用地址。

​        Baggy Bounds Checking（BBC）通过将 OOB 指针与其引用对象之间的距离存储到指针的最大有效位[39]距离中，从而无需分配专用的 OOB 对象。标记最重要的位还会将 OOB 指针变成无效的用户空间指针，因此释放它们会导致错误。BBC 通过将所有分配大小四舍五入到最接近的二次方值来压缩每个对象元数据的大小，以便一个字节的元数据可以存储边界。

​        Low-fat pointer（LFP）边界检查器通过使分配大小可配置来改善BBC，这导致较低的性能和内存开销[42]，[43]。这个想法是将堆分成相等大小每个子堆仅支持一个分配大小。因此，可以通过查找该堆支持的分配大小来获取任何给定指针的分配大小。指针引用对象的基地址可以通过将其舍入为分配大小来计算。LFP 在处理 OOB 指针方面也不同于 BBC。为了与 uninstrumented libraries 更好地兼容，LFP 不会操纵指针表示来对 OOB 指针的引用进行编码。取而代之的是，只要将指针作为显式输入（例如，将指针作为自变量指定）或隐式（例如，从内存中加载的指针）作为函数的输入提供给函数，LFP 都会重新计算每个指针的引用。但是，这要求LFP强制执行不变式，即只要将指针作为其他函数的输入给出，这样在实际程序中好像太严格了（参阅8.1节）。

​        Per-object bounds trackers 可以支持接近完整的空间安全漏洞检测。但是，诸如 BBC 和 LFP 之类的技术确实舍弃了精度，以获得更好的运行时性能----因为它们舍入了分配大小并检查了分配范围而不是对象范围（参见VIII-B节）。

​        Per-object bounds trackers 还有其他缺点。首先，每个对象的边界跟踪器不会检测到对象内部的溢出（参阅8.2节）。其次，通过将指针指向OOB对象或将标记写入其高位标记为OOB可能会影响与未意识到程序中使用的边界检查方案的外部代码的兼容性。特别是，即使意识到了，外部代码也无法将 OOB 指针还原为内部普通入栈指针。

#### 4.1.2 违反时间内存安全 (Temporal Memory Safety Violations)：

**重用延迟 (Reuse Delay):**

​        基于位置的访问检查器可以通过替换为 red zones [27] – [29]， [31]，[34]或guard pages[32]，[ 33]，[35]，[36]来标记新近被释放的对象为非法的元数据。Identity-based checkers 可以用类似的方法使已释放对象的身份无效[55]。只要不重新使用已释放的内存或标识，现有的访问检查机制就可以检测到悬空的指针间接引用。当然如果程序为了重新分配重用了内存或标识，则这种方法将错误地允许悬空指针间接引用继续进行下去（？）。一些基于重用延迟的工具通过延迟内存区域或标识的重用，直到它们“老化” [27] – [29]， [31]，[34]，[55]，来减少此类检测失败的机会。由于较长的重用延迟会导致较高的内存开销，因此这会导致精度与内存开销之间的取舍，而且还会有更大的机会检测悬空指针的间接引用。

​        Dhurjati和Adve（D＆A）建议使用静态分析确定释放的内存何时可以安全重用[35]。D＆A在其自己的虚拟内存页面上分配每个内存对象，但是通过将虚拟内存页面别名到同一物理页面来允许对象共享物理内存页面。当程序释放内存对象时，D＆A会将其虚拟页面转换为 guard page。D＆A还利用称为 Automatic Pool Allocation 的静态分析，将堆划分为池[62]。这种分析可以推断何时不再可以访问池（即使是潜在的悬空指针），此时可以回收池中的所有虚拟页。党等 有人提出了一种不使用池分配的类似系统，因此可以将其应用于无源程序[36]。与D＆A类似，Dang等。在自己的虚拟页面上分配所有内存对象。释放对象后，Dang等人取消映射该对象的虚拟页面。这有效地实现了与保护页面相同的目标，但允许内核释放其用于虚拟页面的内部元数据，从而减少了物理内存开销。为了防止重用未映射的虚拟页面，Dang等人，建议在高地址位（即程序中使用的最高虚拟地址）处映射新页面。尽管这并不排除完全重用未映射的虚拟页面，但理论上在64位地址空间情况，不太可能发生重用。

**锁和密钥 (Lock-and-key)：**

​        基于身份的检查器可以通过为每个分配的内存对象分配唯一的分配标识符（通常称为密钥）并将此密钥存储在  lock location 来检测时间安全违规[46]，[47]，[ 56]。它们还为每个指针的元数据存储  lock location 和期望的密钥。当释放其关联对象时，检查器会从锁定位置撤消密钥。当程序间接引用其密钥与该指针的  lock location 中存储的密钥不匹配的指针时，锁定和密钥检查会检测到时间安全违规。假设使用唯一的密钥，此方法将完全涵盖临时安全违规行为[56]。由于此技术存储每个指针的元数据，它自然补充了使用 per-pointer bounds tracking 来检测空间违规的 identity-based checkers。 lock-and-key 检查器的缺点与 per-pointer bounds tracking 的缺点基本相同：与 uninstrumented code 的兼容性很差，因为 uninstrumented code 无法正确找到元数据；并且运行时开销很大，因为维护用于每个指针都很昂贵。

**悬空指针标记 (Dangling Pointer Tagging )**：

​        标记悬空指针的最直接方法是使调用 free() 函数的指针相关联的值和边界无效[49]。如果在以后的某个时间点间接引用这样的指针，则空间内存安全违规检测机制将触发警告。这种方法的缺点是它不标记悬挂指针的副本，后者以后也可以使用。

​        有几种工具不仅通过标记调用 free() 的指针，还通过维所有内存对象链接到引用它们的任何指针的辅助数据结构，来标记该指针的副本[57] – [60]。Undangle 使用污点跟踪[63]-[65]跟踪指针的创建，并维护对象到指针的映射[57]。

​        每当程序释放内存对象时，Undangle 都可以查询该指针映射，以快速找到指向当前已释放对象的所有悬空指针。Undangle旨在不仅报告使用情况，而且还报告悬挂指针的存在。它有一个可配置的时间窗口，其中它认为悬空指针是潜在的但并非不安全，例如，在嵌套对象释放期间出现的瞬时悬空指针。当此窗口到期时，或更早在程序尝试间接引用该指针时，Undangle报告悬空的指针。

​        DangNull [58]，FreeSentry [59]和DangSan [60]在编译时避开了污点跟踪和工具指针的创建。只要程序分配了指针，这些工具就会通过调用一个称作运行时注册的函数来维护指针映射。每当程序释放内存对象时，工具都会查找所有指向要释放对象的指针，并使它们无效。无效的悬挂指针的后续间接引用会导致硬件陷阱。

​        不基于污点跟踪的悬空指针标记工具具有一些基本限制。首先，它们需要源代码？的可用性，因为源依赖精确的类型信息来确定哪些操作存储新的指针。其次，如果程序以类型不安全的方式（例如，通过将其强制转换为整数）复制指针，则它们将无法维护准确的元数据。第三，也是最重要的是，它们只能将对象链接到存储在内存中的指针，因此不知道存储在寄存器中的指针悬空。基于污点跟踪的工具（例如Undangle）没有这些缺点，但是会带来明显的性能和内存开销。

### 4.2 使用未初始化的变量 (Use of Uninitialized Variables)

​        下述工具检测未初始化值的使用。

**未初始化的内存读取检测 (Uninitialized Memory Read Detection)**：

​        通过将新分配对象占用的所有存储区域标记为在元数据存储中未初始化[27]，基于位置的访问检查器可以扩展为检测未初始化的内存读行为。这些工具如果发现未初始化的存储区域读行为，会读取指令以发出警告，并通过写入来清除覆盖区域的未初始化标记。需要注意的是标记存储区域为未初始化并不等同于将它们标记 red zones，因为 red zones 的读和写访问都会触发警报，而访问未初始化的内存有读行为会触发警告。

**未初始化值使用检测 (Uninitialized Value Use Detection)**：

​        检测未初始化内存的读取会产生许多误报检测，因为C ++ 14标准明确允许未初始化值在不使用的情况下在程序中传递。例如，将部分未初始化的结构从一个位置复制到另一个位置时，就会发生这种情况。Memcheck 尝试通过将错误报告限制为四种情况来检测未初始化值的使用：（i）对（部分）未定义的指针的间接引用；（ii）在（部分）未定义的值上分支(branching)；（iii）将未定义的值传递给系统调用； （iv）将未初始化的值复制到浮点寄存器[28]。为了支持该策略，Memcheck 为程序存储器中的每个部分初始化的字节添加了一个影子状态字节。这使Memcheck能够以位级精度跟踪程序所有内存的定义。Memcheck 近似于C ++14语义，但是会产生假阴性（未能报告未初始化内存的非法使用）和假阳性（报告未初始化内存的合法使用），鉴于Memcheck 在二进制级别而非源代码级别运行，因此这是不可避免的。MemorySanitizer （MSan）基本上执行与Memcheck相同的策略，但是在编译器的中间表示（IR）级别上对程序进行检测[66]。IR代码比二进制代码携带更多的信息，这使得 MSan 比 Memcheck 更精确。MSan不会产生误报（前提是已检测到整个程序）并且几乎不会产生误报。它的性能开销也比Memcheck低一个数量级。

### 4.3 指针类型错误 ( Pointer Type Errors)

​        这些工具检测不兼容类型的指针的类型错误转化和间接引用。

**指针转换监视器 (Pointer Casting Monitor)**：

​        ointer casting monitors 通过 C++ static_cast 运算符检测非法向下转换。当强制转换的目标类型与源对象的运行时类型（或其祖先类型之一）不相等时，将发生非法向下转换。 UndefinedBehaviorSanitizer [67]（UBSan）和Clang CFI [68]包含检查器，这些检查器通过将目标类型与与源对象关联的运行时类型信息（RTTI）进行比较来验证 static_cast 操作的正确性。这有效地将 static_cast 操作转换为 dynamic_cast 。缺点是基于 RTTI 的工具无法验证之间的强制转换缺少 RTTI 的非多态类型。

​        CaVer [69] 和 TypeSan [70] 不依赖 RTTI 来跟踪类型信息，而是维护程序中使用的所有类型和所有对象的元数据。这样，他们可以将类型检查的范围扩展到非多态类型。在编译时，这些工具将构建每个类类型的元数据表，其中包含给定指针类型的所有有效类型强制转换。类型表对类继承和组成关系进行编码。这两个工具还通过监视内存分配并将分配的类型存储在元数据存储中，来跟踪每个活动对象的有效运行时类型。为了执行向下检查，这些工具将检索运行时从元数据存储中获取源对象的类型，然后在类型表中查询相应的类，以检查类型转换是否在表中（因此是允许的）。 HexType 类似地在不连续的元数据结构中跟踪类型信息，但是提供了更准确的运行时类型跟踪[71]。 HexType 还用其自己的优化实现替换了 dynamic_cast 的默认实现，同时保留了其运行时语义，即对于失败的强制转换返回 NULL。

**指针使用监视器 (Pointer Use Monitor)**：

​         C / C ++支持多种以潜在危险的方式转换指针类型构造。C风格的强制转换、reinterpret_cast 和 union 合都可以用来绕过编译时和运行时类型检查。但是，将指针强制转换监视扩展到这些构造可能会导致误报。这是因为程序员可以在语言标准允许的范围内合法使用此类构造它。因此，与指针转换监视相比，可能会选择指针间接引用/使用监视。

​        Loginov 等人提出了用于C程序的指针使用监视器[72]。该工具通过监视 load 和store 操作来维护和验证每个内存位置的运行时类型标签。标签包含最后用于写入其相应存储位置的标量类型。聚合类型通过分解为标量组件来提供支持。该工具将标签存储在影子存储器中。每当从内存中读取值时，该工具都会检查用于加载值的类型是否与type标签匹配。

​        LLVM Type Sanitizer（TySan）还在影子存储器中维护类型标签存储，并验证加载指令的正确性[73]。但是，与 Loginov 等人的工具相反，TySan 不需要用于存储和从内存位置加载的类型完全匹配。相反，TySan仅需要类型兼容性，这由C / C ++标准中的别名规则定义。TySan利用了由编译器前端（Clang）生成的元数据，该元数据包含类型之间的别名关系。该元数据在运行时用于，例如，即使通过使用指向较大类型的指针存储目标位置，也可以通过字符指针类型进行所有加载。Loginov 等人的工具会将其检测为错误，但是语言标准明确允许这种行为。

​         EffectiveSan 是另一个指针使用监视器，它执行类型检查以及指针使用时的边界检查[74]。EffectiveSan 对每个分配站点进行检测，以使用其静态确定的类型标记每个分配的对象。它将声明的变量类型用于堆栈和全局变量，以及使用 C++ new 运算符分配的对象。对于使用 malloc 分配的对象，它使用对象的第一个左值用法的类型。EffectiveSan 还在编译时生成类型布局元数据，其中包含每种类型的所有嵌套子对象的布局信息。在每个指针间接引用时，都使用对象类型标记结合类型布局元数据来检查类型兼容性和对象边界。EffectiveSan 的边界检查支持通过使用类型布局信息在运行时导出子对象边界来检测对象内溢出。

​        几种工具还可以检测间接函数调用中的指针类型错误，即通过与被调用函数的[67]，[68]，[75]类型不兼容的指针来调用函数。基于功能签名的前沿控制流完整性机制，例如 Clang CFI [68]，可以看作是检测此类功能指针误用的 sanitizers。由于所有函数签名在编译时都是已知的，因此这些工具可以检测指针类型和函数类型之间的不匹配，而无需维护运行时标记。

### 4.4 可变参数功能误用 (Variadic Function Misuse)

​        这些工具检测违反内存安全性的行为，未初始化的变量使用特定于可变参数的函数。

**危险的格式字符串检测(Dangerous Format String Detection)**：

​        最常见的可变参数函数滥用错误类别是格式字符串漏洞。因此，大多数工作仅专注于检测对 printf（） 的不安全调用。在这些工作中，有一些工具可以限制在格式字符串[76]，[77]中使用 ％ n限定符。该限定符可用于使 printf（） 写入内存中调用者指定的位置。但是，此危险操作[2]专门用于 printf（） 函数，因此上述工具的适用性受到限制。

**参数不匹配检测（Argument Mismatch Detection）：**

​        FormatGuard 防止 printf（）  读取比调用者传递的参数更多的参数[78]。FormatGuard通过将调用重定向到受保护的printf 实现来实现，该实现每次通过 va_arg  检索可变参数时都会递增计数器。如果计数器超过了在调用处指定的参数数量，则 FormatGuard 会发出警报。HexVASAN 将参数计数推广到所有可变参数函数，并且还添加了类型检查[79]。HexVASAN对可变参数函数的调用站点进行检测，以捕获传递给被调用方的参数的数量和类型，并将此信息保存在元数据存储中。然后，该工具会检测 va_start 和 va_copy 操作从元数据存储中检索信息，并且它对 va_arg 操作进行检测，以检查所访问的参数是否在给定数量的参数和给定类型内。

### 4.5 其他漏洞

这些工具可以检测其他未定义的行为或定义良好但潜在的意外和危险行为。

**无状态监视 (Stateless Monitoring)**：

UndefinedBehaviorSanitizer（UB-San）是一种动态工具，可检测到我们目前尚未介绍的未定义行为[67]。UBSan 当前检测到的未定义行为包括有符号整数溢出、浮点数或整数被零除、无效的按位移位运算、由强制转换引起的浮动点溢出（例如，将大的双精度浮动点数强制转换为单精度变量）、使用未对齐的指针、执行使指针溢出的算术运算、间接引用空指针、带返回值函数分支尾部不返回值。UBSan的大多数检测功能都是无状态的，因此可以集体打开它们而不会互相干扰。 UBSan 还可以检测到几种定义良好但很可能出乎意料的行为。例如，语言标准规定无符号整数溢出时会回绕。这种定义良好的行为通常是出乎意料的，并且经常是错误的来源，因此 UBSan 可以选择检测这些无符号整数环绕。

## 5. PROGRAM INSTRUMENTATION

​         sanitizers通过将内联引用监视器（IRM）嵌入到程序中来实现其错误查找策略。这些 IRM 监视和调解可能导致漏洞的所有程序指令。这样的指令包括（但不限于）内存 load 和 store、stack frame (de) allocations、对内存分配函数的调用（例如 malloc ）、系统调用。可以使用编译器，链接器或检测框架来嵌入IRM。

### 5.1 源码层次检测 (Language-level Instrumentation)

​        可以将 sanitizers嵌入源代码或抽象语法树（AST）级别。源代码和AST是特定于语言的，通常包含完整的类型信息、语言的特定语法、编译时间评估的表达式，例如 const_cast 和 static_cast 类型转换。语言特定信息通常在 AST 转化为更为底层的 IR 层次时被丢弃。对于通过指针转换监视来检测指针类型错误的 sanitizers，建议（甚至是必要）使用语言级别的检测。

​        在语言级别进行检测的另一个优点是，编译器在整个编译的早期阶段都保留了程序的完整语义。因此， sanitizers可以看到程序员打算使用的语义。在编译的后期阶段，编译器可以假定程序不包含未定义的行为，并且可以基于此假设优化代码（例如，通过消除看似不必要的安全检查）。在语言级别进行检测的缺点是应用程序的整个源代码必须可用，并且代码必须以预期的语言编写。因此，该方法不适用于链接到闭源库的应用程序，也不适用于包含内联汇编代码的应用程序[80]。

### 5.2 IR层次检测 (IR-level Instrumentation)

​        当 AST 被转化为更为底层的 IR 代码中时， sanitizers也可以嵌入到后期编译中。诸如 LLVM 之类的编译器后端支持 IR 层次的检测[81]。这种方法比源代码级转换更通用，因为编译器 IR （通常）独立于源语言。因此，通过在此级别进行检测， sanitizers可以自动支持多种源语言。另一个优点是，编译器后端实现了可以由 sanitizers使用的各种静态分析和优化过程。 sanitizers可以利用此基础结构来优化它们嵌入到程序中的IRM（例如，通过删除冗余或可证明安全的检查）。

​        IR级别仪器的缺点与语言级别仪器的缺点在很大程度上相似，即缺乏对闭源库和内联汇编代码的支持（第5.1节）。例外地，AddressSanitizer（ASan）确实通过检测内联汇编块中的 MOV 和 MOVAPS 指令，为内联x86汇编代码提供了有限的支持[31]。但是，这种方法是特定于体系结构的，需要针对每个受支持的体系结构重新实现或复制。

### 5.3 二进制检测 (Binary Instrumentation)

​        动态二进制翻译（DBT）框架允许在运行时对程序进行检测[82]-[84]。他们读取程序代码，对其进行检测，然后在程序执行时将其翻译为机器代码，并暴露各种影响执行的钩子（hooks）。编译器为基础的基于DBT的工具的主要优点是他们在闭源程序上表现不错。此外，DBT框架无论源码是啥，都提供了对用户模式代码的完整检测覆盖。DBT框架可以检测程序本身、第三方代码（可以动态加载）、甚至动态生成的代码。

​        与静态仪器工具相比，DBT 的主要缺点是运行时性能开销高得多（参阅第8.5节）。该开销可以主要归因于运行时指令的解码和翻译。通过使用静态二进制检测（SBI）框架对二进制文件进行静态检测，可以部分解决此问题。但是，基于  SBI 和 DBT 的 sanitizers都必须操作实际中不包含类型信息或特定语言文法的二进制文件。因此，在此阶段无法嵌入指针类型错误的 sanitizers。关于堆栈帧和全局数据节布局的信息也在二进制级别丢失，这使得使用二进制检测时无法插入完全精确的空间内存安全 sanitizers。

### 5.4 库打桩 (Library Interposition)

​        尽管非常粗糙，有一种使用库打桩（interposer）拦截对库函数的调用的方法[85]。库打桩是一个共享库，当将其预加载到程序中时[86]，它可以拦截、监视和操纵程序中的所有库间函数调用。一些 sanitizers使用此方法来拦截对内存分配函数（例如 malloc 和 free ）的调用。

​        这种方法的优点是，与基于 DBT 的工具类似，它对于 COTS 二进制文件也很有效，而不需要源代码或目标代码。但是，与 DBT 相反，库插入几乎不会产生任何开销。缺点之一是，库插入仅适用于库间调用。同一库中两个函数之间的调用不能被拦截。另一个缺点是库插入是高度平台化和特定于目标的。例如，使用库插入来拦截对 malloc 的调用的 sanitizers不适用于具有自己的内存分配器的程序。

## 6. META DATA MANAGEMENT

​         sanitizers设计的一个重要方面是它如何存储和查找元数据。该元数据通常捕获有关程序中使用的指针或内存对象的状态的信息。尽管运行时性能不是 sanitizers开发人员或用户的主要考虑因素，但是大多数 sanitizers存储的元数据数量巨大，这意味着即使存储方案中的效率低下，也会使 sanitizers的运行速度降低到令人无法接受的程度。元数据存储方案还大致确定了是否可以结合使用两个 sanitizers。如果两个独立的 sanitizers都使用元数据方案来更改程序中的指针和/或对象表示，则它们通常不能一起使用。

### 6.1 对象元数据 (Object Metadata)

​        一些 sanitizers程序使用对象元数据存储方案来存储所有分配的内存对象的状态。这种状态可能包括对象的大小，类型，状态（例如，已分配/已释放，已初始化/未初始化），分配标识符等。

**嵌入式元数据 (Embedded Metadata)**：*

​        存储对象*元数据的*一种显而易见的方法是增加其分配大小，并将元数据附加或预置到对象的数据之前。这种机制在现代内存分配器中很流行，例如，将缓冲区的长度存储在实际缓冲区的前面。工具可以修改内存分配器，以透明地为请求的缓冲区大小之外的元数据保留内存，然后将指针返回到此分配的中间，以使客户端看不到元数据。ASan [31]和 Oscar [36]等使用了嵌入分配的元数据。ASan 将有关分配上下文的信息嵌入到每个分配的对象中。Oscar 将每个对象的规范地址存储为嵌入式元数据。

**直接映射阴影 (Direct-mapped Shadow)**：

​        该直接映射阴影方案将应用程序内存中的每个 n 字节块经由公示映射到元数据的 m 字节：

```c
// shadow_base is the base address of the metadata store
// block_addr is the address of the memory block
metadata_addr = shadow_base + m * (block_addr / n)
```

​         例如，ASan [31] 每8个字节的应用程序内存就存储1个字节的元数据。在这种情况下，阴影映射公式可以简化为：

```c
metadata_addr = shadow_base +（block_addr >> 3）
```

​        该直接映射阴影方案容易实现，并加入到应用程序。由于只需要读取一次内存即可检索任何给定对象的元数据，因此它通常也非常有效。在某些情况下，它也会导致运行时性能变差，因为它可能使已经碎片化的地址空间中的存储器碎片（进而导致空间局部性）恶化。由于影子存储区域是连续的，并且必须足够大以镜像所有分配的存储块（从最低虚拟地址到最高虚拟地址），因此在分配内存方面也很浪费。

**多级阴影 (Multi-level Shadow)：**

​        该多级阴影方案可以通过以目录表的形式引入间接附加层减少元数据存储的内存占用量。这些目录表可以存储指向元数据表或其他目录表的指针。每个元数据表都直接镜像应用程序内存的一部分，类似于直接映射的影子方案。整体而言，多层次影子方案类似于现代操作系统如何实现页表。具有附加的间接层允许元数据存储按需分配元数据表。他们只需要自己分配目录表，就可以推迟元数据表的分配，直到需要它们为止。这对于地址空间有限的系统（例如32位系统）特别有用，在这些系统中，实现直接映射阴影方案的 sanitizers（例如 ASan [31]）经常会耗尽可用的地址空间并导致程序终止。

​        需要按对象元数据（与按字节元数据相反）的工具可以使用 variable-compression-ratio 多级阴影映射方案，其中目录表将可变大小的对象映射为恒定大小的元数据。这个方案可以帮助工具优化其影子内存使用率和分配时间性能[87]。

​        此方案的主要特征是每个元数据访问都需要多个内存访问：一个用于目录表的每个级别，另一个用于对应的元数据表。这会显着影响性能，特别是对于那些频繁查找元数据的工具，例如，边界检查工具，它需要对大多数内存访问进行元数据访问。例如，TypeSan [70] 是两级 variable-compression-ratio 方案的理想选择，因为类型元数据是针对每个对象的，且大小恒定，并且元数据查找很少。

**自定义数据结构 (Custom Data Structure )：**

​        除了先前介绍的元数据方案的变体之外，一些工具作者还选择了一系列自定义数据结构和特定于工具的解决方案来存储元数据。边界检查器（例如 J＆K，CRED 和 D＆A ）使用展开树[34]，[37]，[38]。UBSan 和 CaVer 使用附加的哈希表作为缓存来存储类型检查的最新结果[67]，[69]。DangNull 利用线程安全的红黑树对对象之间的关系进行编码[58]。请注意，当使用不支持并发访问的数据结构时，必须通过多线程设置中的显式锁来保护它。对于线程局部变量或堆栈变量，每个线程的元数据也是一种选择，例如，CaVer 对于堆栈和全局对象有每个线程的红黑树。

### 6.2 指针元数据 （Pointer Metadata）

**胖指针 (Fat Pointers)**:

​        某些 sanitizers将 Fat Pointers 替换为标准机器指针。Fat Pointers 是包含原始指针值以及与原始指针关联的元数据的结构。在许多按指针范围跟踪工具中使用一种非常简单的  fat pointe 布局是：

```c
struct fat_pointer {
void * value; // Original pointer value
void * base; // Base address of the intended referent
size_t size; // Size of the referent
};
```

​        使用胖指针的主要优点是，与常规指针相比，它们不会增加太多额外的缓存压力，并且它们可以存储任意数量的元数据。缺点是它们需要程序的大量 instrumentation，它们会更改接受指针参数的函数的调用约定（胖指针作为函数参数传递时占用多个寄存器），并且不能在与之交互的程序中使用 uninstrumented third-party libraries 。没有 instrumentation，这些库将无法正确解释胖指针，当嵌入的内部指针值更改时，它们也无法更新胖指针。

**标记指针 (Tagged Pointers)**：

​        一种存储每个指针元数据的侵入性较小的方法是用标记指针替换常规的机器指针。带标记的指针在不更改其大小的情况下将元数据嵌入指针本身。与胖指针相比，此技术提供了更好的兼容性。例如，将标记的指针作为函数参数传递不需要更改标准的调用约定。与常规机器指针相比，另一个优点是标记的指针不会引入任何额外的缓存压力。依赖于标记指针的工具通常将标记存储在原始指针的未使用位中。因此，标记指针可以编码的信息量受到给定目标平台的未使用地址空间大小的限制。例如，大多数AMD64平台（包括Linux / x86 64）仅将最低的256 TiB虚拟地址空间用于用户模式应用程序。因此，任何有效的用户模式指针的高16位都保证为零。这16位可以存储 per-pointer metadata 。Baggy Bounds Checking 使用备用位来存储 OOB 指针与其预期引用对象之间的距离[39]。在运行在64位处理器上的32 位 SGX安全区，任何指针的高32位均为零。SGXBounds使用这32位来存储指针所指对象的上限[54]。

​        CUP进一步使用整个指针宽度来存储标签，从而完全丢弃了原始指针值[55]。CUP存储在标记指针中的标记之一是元数据表中的偏移量，该元数据表包含原始指针值。

​        注意，标记的指针通常不能直接释放引用对象。CUP需要先删除已标记指针的原始指针值，然后才能将其释放引用；而大多数其他工具则需要先屏蔽掉标记，然后再释放对已标记指针的引用。这对于转义到 external uninstrumented libraries 的标记指针也是必需的。一个例外是基于  low-fat pointer-base 的工具，该工具将标签隐式存储在指针值中，并且可以直接释放引用[42]，[43]。

**不连续的元数据 (Disjoint Metadata)**：

​        将元数据存储在不连续的元数据存储中，而不是将其嵌入到指针表示中，可以提高上述方法的兼容性。但是，与 per-object metadata 相比， sanitizers 通常不使用直接映射的影子存储来维护 per-pointer metadata（请参阅第6.1节）。指针占用的内存部分通常很小，并且指针元数据（例如，边界）的大小往往会超过指针本身的大小，从而导致地址空间的浪费。因此，即使以牺牲额外的内存访问为代价，工具作者也倾向于使用多层结构进行维护。每个指针的元数据。CETS 利用两级查找树（类似于页表），使用指针位置作为键来存储分配标识符和引用对象的锁定地址[56]。Intel Pointer Checker [49]和 Intel MPX [88]也使用两级结构来维护指针界限。

​        与指针内元数据相比，不连续的元数据的主要缺点是，每当程序将指针复制到新的内存位置时， sanitizer 都必须显式传递元数据。例如，如果程序调用 memcpy 复制包含指针的数据结构，则 sanitizers 必须更新目标数据结构中指针的元数据存储。与在指针的元数据，相比之下，元数据总是与指针一起传递。

### 6.3 静态元数据 (Static Metadata)

某些 sanitizers 需要编译器丢弃的某些信息才能在运行时执行检查。为了在运行时提供所需的编译时信息，这些 sanitizers通常将静态元数据嵌入到已编译的程序中。例如，bad-casting sanitizers 在编译时创建类型层次结构表，以便于在运行时进行类型转换检查。HexVASAN 是可变参数函数调用 sanitizer，它为每个可变参数调用站点构建静态元数据，以对参数的数量及其类型进行编码。在运行时，instrumented caller 将静态元数据推送到自定义堆栈上，callee 使用该堆栈检查提供的参数的有效性。

## 7.  RIVING A SANITIZER

​        动态分析工具（包括 sanitizers）仅检测在测试期间执行的代码路径上的错误。因此，增加路径覆盖范围会增加发现错误的机会。程序执行可以由单元或集成测试套件、自动测试用例生成器、alpha 和beta 测试器、其任意组合来驱动。

​        单元测试和集成测试已经是软件工程中的最佳实践。传统上，编写这些测试是一个手动过程。尽管通常是必不可少的，但是在用于 sanitizers时，使用手写测试确实有一些缺点。首先，手动编写的测试通常侧重于使用 valid 输入来检查预期行为的 positive 测试。但是，安全漏洞通常在向程序提供 invalid 输入时被利用。其次，手动编写的测试几乎不会覆盖 all 代码路径。

​        开发人员可以使用自动测试用例生成器来改善这些问题。一种选择是使用符号执行，它可以系统地探索所有可能的执行路径以生成具体的程序输入[6] – [9]。然后可以将这些输入喂入 sanitized programs 中以查找错误。但是，由于路径爆炸问题和约束解决的成本，这种方法通常无法完全实现。更具可扩展性的选项是在在 sanitized programs 上运行 fuzzer[89]-[94]。Fuzzer是一种测试工具，可以在自动生成的输入上运行程序，通常使用轻量级动态程序分析，例如覆盖率反馈。Fuzzers 执行否定测试，因为它们倾向于向程序提供 invalid inputs，并且可以相对较快地找到安全漏洞，尤其是当漏洞是在易于访问的代码路径上被触发时。

​        最后，开发人员可以将启用了 sanitization-enabled programs 发送给Beta测试人员，并收集和交付所有 sanitizers 输出给开发人员。这里的主要优点是Beta测试人员可以分配测试负载，因此使开发人员可以更快地定位错误。缺点之一是 Beta 测试人员会无意间专注于测试程序的主要使用场景。另一个缺点是， sanitizers 可能会使程序减慢到无法使用的程度，从而降低 beta 测试人员彻底测试程序的机会。Lettner等人[95]证明了 partitioned sanitization ，在运行时根据覆盖率和执行速度等标准在打开和关闭  sanitization 的情况下，这可以在有 sanitizers 组成时减少这种担忧。



## 8. ANALYSIS

​        表II（见原文）总结了正在积极维护（作为开源项目或商业产品）或在学术会议上发布的 sanitizers 的特性。我们包含的某些工具最初是为 exploit mitigation 而设计的，因此没有内置的报错机制。但是，这些工具确实符合我们 sanitizers 的定义（请参阅第2节），因为它们可以指出易受攻击的代码的确切位置，并且与调试器结合使用时可以提供有用的反馈。我们排除了 Intel Inspector [96]，ParaSoft Insure ++ [75]，Micro Focus DevPartner [97]和UNICOM Global PurifyPlus [98]，因为缺少有关这些 sanitizers 的公共信息无法进行准确的比较。

​        对于每个 sanitizers，该表显示了它发现的错误，发现这些错误的技术以及使用的元数据存储方案（如果有）。饼形代表我们对 sanitizers的有效性以及其在运行时和内存开销方面的效率的评估。彩色的单元格表示已知 sanitizers会产生假阳性误报。我们在第8.1节中讨论这些误报的原因。通过在相同的实验平台上使用相同的基准测试套件运行这些工具中的10个（即表II中其性能开销单元标有星号的工具），我们验证了报告的性能数字。我们在附录A中报告了这些工具的确切性能数字。

### 8.1 误报（False Positives）

​        Sanitizers 的实用性主要取决于其报告错误的准确性。使用 sanitizers的开发人员希望最大程度地减少检查其错误报告所花费的时间。因此，对于 sanitizers而言，最理想的属性是它不会误报（即，报告的所有错误都是真正的错误），而假阴性漏报情况（即，sanitizer 发现所有可能的错误）是次要问题。我们确定了以下可能导致误报检测的重复出现的问题。

​        最经常出现的问题是， sanitizers 通常实施比语言标准或实际标准都严格的错误发现策略或机制。实际标准包括被广泛遵循的编程实践，尽管它们会导致无错误的代码，但它们不一定符合语言标准[99]。因此，人们可能会争辩说，将不符合实际标准的行为视为错误构成了误报。

​        诸如 J＆K 之类的较早的 per-object bounds trackers 不允许创建指向数组末尾的 OOB 指针[34]。该设计决策与语言标准兼容，但与实际标准不兼容。创建OOB指针在实际程序中很常见，除非程序间接引用了 OOB 指针，否则不会导致问题。随后的per-object bounds trackers（例如 CRED ）允许程序创建 OOB 指针。

​        临时存储OOB指针的程序也可能导致悬挂指针检查器的问题[58] – [60]。这些工具无法识别OOB指针的预期引用，因此无法将指针注册到正确的对象。如果预期的引用对象被释放后，悬挂的指针检查器将不会使 OOB 指针无效。更糟糕的是，如果临时的 OOB 指针在注册时碰巧指向一个有效对象（不同于其预期的参考对象），然后当程序释放该对象时，指针检查器将错误地使指针无效。

​        暂时使用 OOB 的指针还会在基于  low-fat pointer-based bounds checkers [42]，[43]中引起问题，每当指针从函数中转出时，边界检查器都会执行边界检查。如果将 OOB 指针传递给将该指针转换了其原始内部值的函数，则检查器将发出误报警告。

​        当程序读取未初始化的内存时，未初始化的内存读取检测器会发出警告[27]。语言标准允许这样做，只要程序中未使用未初始化的值即可。

​        在某些情况下，某些指针类型错误检查器无法捕获对象的有效类型[69]，[70]。例如，如果使用 C++ 中的 new 布局重新分配了内存区域的用途，则这些检查器可能无法更新或使与该区域关联的类型元数据无效。当使用旧类型进行类型检查时，这可能导致误报的检测。

​        某些工具不遵守语言标准的别名规则。Loginov 等人的指针使用监视器要求使用与对象的运行时类型相同的类型访问对象的存储值[72]。HexVASAN 要求给定的参数类型与 va_arg  [79]中使用的参数类型相同。这些工具将生成错误警报，例如，当程序合法使用字符类型指针来给不同类型的对象取别名时（？）。

### 8.2 漏报 (False Negatives)

​        漏报（即，无法报告范围内的错误）是由于错误发现策略与实施该策略的机制之间的差异而引起的。我们确定了几种错误发现机制，这些机制不能完全覆盖该策略应涵盖的所有错误。

​        基于 red-zones 插入和 guard pages 的空间安全违规检测机制，仅检测到与该访问的预期对象直接相邻的对 red-zones 和 guard pages 的非法访问。不是以 red-zones 和 guard pages为目标时，内存访问时认为对象是有效的。这些相同的机制也无法检测到对象内部的溢出，因为它们没有在同一父对象的子对象之间插入 red-zones 和 guard pages 。

​        使用标记指针的空间安全违规检测器可能会将新分配的对象的分配大小四舍五入为最接近的2的幂[39]，或者最接近的支持的分配大小[42]，[43]。这些检测器执行的边界检查将强制执行分配时的边界，而不是对象边界。因此，如果非法内存访问的目标是添加到对象的填充，则不会报告该填充。

​        Per-object bounds tracking tools 不会检测对象内部溢出，因为它们无法（始终）区分对象指针和子对象指针。例如，当父对象有一个子对象作为其第一个成员时，就会发生这种情况。该子对象与父对象位于相同的内存地址。

​        location-based checking or guard pages 的时间安全违规检测机制无法检测到，已被重新用于新的内存分配的悬空指针的间接引用。可以通过在有限的时间内延迟内存重用来改善此问题，或者如果池分配分析可以确定何时不能再访问释放后的引用，则可以消除此问题[35]。但是，只有在类型信息可用时，才在编译时进行池分配分析。

​        基于 guard page 的时间安全违规检测器无法使超出范围的局部变量无效。这些局部变量存储在堆栈帧中。这些框架无法用  guard pages 替换，因为它们通常与仍在使用的其他框架共享内存页。因此，基于 guard page 的技术不能检测 use-after-scope 和 use-after-return 这样的漏洞。

​        基于悬空指针标记的时间安全违规检测器仅会使存储在内存中的指针无效。即使程序最终将它们复制到内存中，存储在寄存器中的悬空指针也不会失效。

​        大多数未初始化的内存使用检测器通过仅在有限的情况下（例如，将其传递给系统调用时或在分支条件下使用时）才将值视为“已使用”来去近似地匹配语言标准。

​        指针类型错误检测器（例如TySan [73]）也保守地近似了语言标准的有效类型规则，因此无法检测到涉及系统类型未知的对象的错误。

​        某些 sanitizers 无法识别转换为整数或通过 memcpy 复制的指针。例如，使用不连续的 per-pointer metadata 的基于身份的访问检查程序通常无法在这些构造之间传递指针的范围。此问题还影响通过标记指针类型变量的存储来标记悬空指针的 sanitizers，但是漏报临时转换为整数或以类型不安全的方式复制的指针。

### 8.3 检测不完整 (Incomplete Instrumentation)

​         静态测试程序的 Sanitizers 不能完全支持在运行时（例如，实时编译器）或没有或不能进行检测的外部库程序（例如，由于其源代码是不可用）。某些在编译器IR级别检测程序的 sanitizers也不支持包含嵌入汇编代码的程序，因为编译器前端不会将此类代码转换为编译器IR代码。在所有这些情况下， sanitizers可能无法插入检查，从而可能导致漏报。例如，如果程序从动态生成的代码块中访问内存，则违反空间安全性的 sanitizer 通常将无法验证内存访问是否合法。

​        而且， sanitizers也可能无法发出必要的指令来更新元数据。对于需要传递传播元数据（例如，无关的 per-pointer metadata 或内存状态位）的 sanitizers来说，这尤其成问题[46]-[49]，[52]，[56]，[66]。例如，如果程序从外部 uninstrumented library 中复制了一个指针与无关的元数据到新的存储位置，则 sanitizers将不会复制源指针的元数据。如果没有适当的元数据传播， sanitizers可能会产生漏报（因为存储中可能缺少元数据）或误报（因为元数据可能已过期）。

​        对于某些更改指针指向的工具，Incomplete Instrumentation 也是一个问题[39]，[45]，[46]，[54]，[55]，因为传递 fat/tagged pointers 给 uninstrumented 的代码可能导致崩溃，而解析从uninstrumented 的代码接受的代码会导致检测的漏报或误报。

​        这些问题可以通过在运行时嵌入 sanitizers 来解决，而可以使用动态二进制 instrumentation 框架来解决。但是，这些框架无法提供准确的类型信息，因此不支持某些类型的 sanitizers（例如，指针转换监视器）。

### 8.4 线程安全 （ Thread Safety）

​        在多线程程序中，维护指针和对象的元数据的 sanitizers可能导致误报和漏报。之所以会发生这种情况，是因为它们可能以线程不安全的方式访问元数据结构，或者因为 sanitizers 不保证它与程序对其关联的指针或对象的原子更新在同一事务中更新元数据。前一个问题影响 FreeSentry [59]，并使 sanitizers无法支持多线程。后一个问题会影响 Intel Pointer Checker [49]， Intel MPX [88] 和 MSan [66] 等。这些 sanitizers 允许指针或对象与其元数据不同步，这可能导致误报和/或漏报。诸如Memcheck [28]之类的某些 sanitizers 通过序列化多线程程序的执行来规避此问题，从而始终以原子方式自动更新元数据以及与之关联的指针和对象。

### 8.5 绩效开销 （Performance Overhead）

​        Sanitizers 的运行时性能要求不如 exploit mitigations 的要求严格。尽管后者通常仅在运行时开销保持在5％以下的情况下才能进行实际部署[15]，但我们观察到，实际使用的 sanitizers开销不到3倍。在某些情况下，例如当程序的源代码不可用（完全可用）或程序即时(on-the-fly)生成代码时，甚至可以接受高达20倍的较大开销。但是，有充分的理由尝试尽量减少 sanitizers 的开销。特别是一个原因是 sanitizers变得越快，启用 sanitizers 的速度就越快程序可能很 fuzzed。反过来，这使得 fuzzer 可以在停止取得有意义的进展之前探索更多的代码路径(请参阅第7节)。

​        Sanitizers运行时开销的主要因素是其检查、元数据存储和传递、以及运行 instrumentation 成本。该运行时 instrumentation 的成本是大多数 sanitizers为零，因为他们静态地 instrument 程序（在编译时）。但是，对于使用动态二进制工具的 sanitizers，运行时工具成本可能很高。例如，Valgrind 的 Memcheck [28] 在 SPEC2000 基准测试中产生25.7倍的开销。这种运行时开销的4.9 倍可以归因于基于 DBT 框架 MemCheck 的 Valgrind 本身[84]。

​        元数据存储和传递成本主要取决于元数据存储方案。通常，嵌入元数据和 tagged or fat pointers 是最有效的存储方案，因为与 disjoint/shadow 元数据存储方案相比，它们导致的缓存压力较小。嵌入元数据和 tagged or fat pointers 的另一个优点是，复制对象或指针时，它们的元数据会自动传递。但是，在检测不完全的程序中，使用 tagged or fat pointers 是有问题的（参见第6.2节）。一个例外是 low-fat pointer-based bounds tracking [42]，[43]，其中元数据隐式存储在标记的指针中，以便 tagged pointer 仍可在 uninstrumented libraries 间接引用。在实践中，我们注意到 disjoint/shadow metadata 存储方案比 tagged and fat pointers 更可取，尽管它们会导致更多的缓存压力，并且在复制对象或指针时需要显式的元数据传递。

​        检查成本与 sanitizers 的检查频率密切相关，而检查频率又很大程度上取决于 sanitizers 的类型。由于内存错误检测器通常需要覆盖程序执行的所有内存访问或指针算术运算，因此与其他工具（例如监视较小操作集的类型转换检查器）相比，它们会引入更多开销。一些内存错误检测工具提供选择性的工具，例如仅监视内存写入，以降低覆盖范围为代价实现更好的性能。

### 8.6 内存开销 (Memory Overhead)

​        增大内存对象分配大小或使用 disjoint or shadow metadata 存储方案的 Sanitizers 具有相当大的内存占用量。在可寻址内存空间有限的32位平台上，这可能会出现问题。例如，ASan [31]将 red zones 插入每个内存对象，并维护直接映射的阴影位图以存储可寻址性信息。因此，ASan将 SPEC2006 基准测试的内存使用量平均提高了3.37倍。基于Guard page 的诸如 Electric Fence [32]和 PageHeap [33]之类的内存安全 sanitizers，会在动态分配的对象的末尾插入整个内存页，因此具有更大的内存占用量。但是，一般而言，即使 sanitizers为程序中的每个对象或指针存储元数据，大多数 sanitizers也会平均将程序的内存占用量增加不到三倍。

## 9. DEPLOYMENT

​        我们研究了 sanitizers 的当前使用情况。我们的目标是确定（i）开发人员偏爱哪种 sanitizers；（ii）以及与那些不被喜欢的 sanitizers 相比有何不同。

### 9.1 Methodology

**Popular GitHub repositories ：**

我们编译了 GitHub上前一百 C 和 C++ 语言项目，并检查了他们的打包生成和测试脚本、GitHub issues、提交历史。我们审查的大多数 sanitizers都需要在编译时集成到测试过的的程序中。因此，程序的打包生成配置将显示其是否为定期 sanitized 的。我们对测试套件和测试脚本的检查进一步表明，可以在测试期间启用哪些 sanitizers。与构建系统/配置文件相反，在此处将显示对在运行时 instrument programs 的 sanitizers（例如Memcheck）的引用。

**Sanitizer web pages**：

​        我们检查了网站上的 sanitizers工具，并使用 sanitizers 和对发现 bug 的确认来寻找项目的明确引用。

**Search trends**：

​        我们检查并比较了不同 sanitizers的搜索趋势。我们将 ASan 作为搜索趋势的基线，因为我们的研究表明，ASan 是目前应用最广泛的 sanitizer。

### 9.2  Findings

**AddressSanitizer is the most widely adopted sanitizer :**

​        我们发现 GitHub 上最受欢迎的 C 和 C++ 项目中的24个和19个分别使用了 ASan 。我们认为，这种受欢迎程度可以归因于 ASan 的多项优势:（i）ASan 用可能性最高的漏洞类别检测漏洞（违反内存安全性）；（ii）ASan 具有高度的兼容性，因为在 not fully instrumented 程序中，它不会引起其他误报(例如，由于程序加载 uninstrumented shared libraries);（iii）ASan 通常具有较低的误报率，可以通过在程序中添加注释或将误报检测发生的位置添加到黑名单中来抑制确有检测到发生的误报；（iv ）ASan 已集成到主流编译器中，只需要对测试程序的构建系统进行微不足道的更改；（v）ASan 可扩展到大型程序，例如 Chromium 和 Firefox Web 浏览器。ASan和结合了带有 red-zone 的 location-based checking 的其他 sanitizers的缺点是存在漏报。

​        一个有趣的发现是基于 DBT 的内存安全 sanitizers（例如 Memcheck 和Dr. Memory ）具有几乎相同的优势。此外，即使程序源代码的一部分不可用，这些 sanitizers也可以始终检测整个程序。然而，我们的研究表明，虽然 Memcheck 在将 ASan 引入 LLVM 和 GCC 之前很流行，但其实际使用情况现在落后于 ASan。Dr. Memory 是一种更为新的工具，其使用率从未达到任何一家竞争对手。

**The adoption rate for other LLVM-based sanitizers is lower：**

​        MSan 和 UBSan 也得到采用，这主要是由于对漏洞的关注度提高，例如未初始化的内存使用和整数溢出。但是，用户经常报告较高的误报率，要避免这种情况，需要付出很大的努力。实际上，开发人员必须花大力气将这些 sanitizers 应用于大型项目，例如 Chromium Web 浏览器。为避免 MSan 误报，必须检测整个程序。在 Chromium 的情况下，这意味着必须将 MSan 插入到Web 浏览器中，包括后者的所有依赖项。对于 UBSan，开发人员维护了一长串的管制，最明显的是抑制了整个 V8 JavaScript 引擎中的所有检测。

### 9.3 Deployment Directions

​        部署风格情况暗示了 sanitizers 的理想特性。首先，所有部署的 sanitizers 都易于使用。具体来说，可以通过编译器标记（Clang sanitizers）启用它们，也可以将其应用于任何二进制文件（Memcheck）。其次，误报率与采用率成反比，即，误报率越低意味着采用率越高?（ASan 和 Memcheck vs MSan 和 UBSan）。第三，性能开销不是主要问题（使用Memcheck），但是可以使用更快的替代方法（Memcheck vs ASan）避免。

​        我们自己将 sanitizers 应用于 SPEC 基准的经验表明，与广泛部署的 sanitizers 相比，研究原型受误报的影响更大（参见原文档表III）。ASan 成功运行了所有基准测试，正确报告了 SPEC 中的已知错误。Memcheck 运行了除 447.dealII 之外的所有基准测试，这需要超过48小时才能完成。相反，由于过于严格（例如，不支持整数指针）兼容性（例如，无法更新在 uninstrumented  libraries 中创建的指针 的边界）的问题，SoftBound + CETS 产生了很多错误的警告，无法运行许多基准测试。LFP 无法运行多个基准测试，因为假定 OOB 指针无法脱离于创建函数的不变性过于严格。DangSan提供了自己的补丁程序，以防止指针的错误无效。

​        想要解决项目中内存安全问题的开发人员可以轻松地选择 ASan 或 Memcheck 。但是，他们应该意识到，这些工具不会检测所有类型的内存安全违规。希望采用 MSan 和 UBSan 的开发人员应该期望继续努力以重新编译所有依赖项和/或将其列入黑名单和注释，以消除误报。对于这些流行的 sanitizers 未涵盖的漏洞（例如，对象内溢出和由类型调整引起的类型错误），开发人员当前没有可行的选择。由于现有的研究原型无法适应实际的代码库，因此需要在这一领域进行进一步的研究。

