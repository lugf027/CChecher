# 2019 IEEE Symposium on Security and Privacy

# SoK: Sanitizing for Security

<p align="center">
    Dokyung Song, Julian Lettner, Prabhu Rajasekaran,<br/>
    Yeoul Na, Stijn Volckaert, Per Larsen, Michael Franz<br/>
    University of California, Irvine<br/>
    {dokyungs,jlettner,rajasekp,yeouln,stijnv,perl,franz}@uci.edu
</p>


[TOC]



## 摘要

​        众所周知，C和C ++编程语言是不安全的，但仍然是必不可少的。因此，开发人员会采取多管齐下的方法来解决对手面前的安全问题。这些包括手动，静态和动态程序分析。动态错误查找工具（以下称为 “消毒程序”）可以查找其他类型的分析错误，因为它们会观察程序的实际执行情况，因此可以在发生错误时直接观察错误的程序行为。

​        大量的消毒程序已由学术界原型化，并由从业人员完善。我们提供了消毒程序的系统概述，重点是消毒剂在发现安全问题中的作用。具体来说，我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。

## 1、INTRODUCTION

​        C和C ++仍然是底层系统软件（例如，操作系统内核，运行时库和浏览器）的选择语言。关键原因在于它们高效且使程序员可以完全控制底层硬件。但另一方面，程序员必须确保每个内存访问都是有效的，没有计算会导致未定义的行为，等等。在实践中，程序员通常没有履行这些职责，并引入了使代码容易受到利用(容易发生漏洞并被利用这些漏洞)的错误。

​       同时，绕过(错开了)诸如地址空间布局随机化（ASLR）和数据执行保护（DEP）之类广泛采用的缓解措施，内存破坏漏洞的利用也越来越复杂[1] – [4]。代码重用攻击（例如，面向返回的编程（ROP））破坏了控制方面的数据（如函数指针或返回地址），从而劫持了程序的控制流 [1]。纯数据攻击(例如面向数据的编程（DOP）)利用 可以在合法控制流路径上调用的 指令，并通过仅破坏程序的非控制数据 来破坏程序[4]。

​        作为针对错误的第一道防线，程序员在将软件部署到生产环境之前，会使用分析工具来识别安全问题。这些工具依赖于静态程序分析、动态程序分析或静态与动态程序分析相组合。静态工具分析程序源代码，并**产生对于所有可能的代码执行都保守地正确的结果**[5] – [9]。相反，动态错误查找工具（通常称为“消毒程序”）分析单个程序执行并**输出仅对单个运行有效的精确分析结果**。

​        消毒程序现已得到广泛使用，并负责发现许多漏洞。但是，尽管它们在发现漏洞中无处不在且起着关键作用，但消毒程序通常并没有被很好地理解，这阻碍了它们的进一步发展和采用。实际上，尽管该领域有大量研究工作，但只有少数研究得到采用，从而使许多类型的漏洞都没有得到解决。本文提供了消毒程序的系统概述，重点是消毒程序在发现安全漏洞中的作用。我们对可用工具及其涵盖的安全漏洞进行分类，描述其性能和兼容性，并强调各种折衷方案。根据我们的发现，我们对开发人员的发展或研究方向提出以下三个目标（i）找到现有工具所检查不到的漏洞，（ii）改善实际中程序的兼容性（iii）更高效地找到漏洞的方法。

​        本文的其余部分安排如下：我们从对消毒程序和漏洞缓解措施两者间高层次表现比较开始（第2节）。接下来，我们描述C / C ++中的低层次漏洞（第3节）和分类技术以检测它们（第4节）。然后，我们继续介绍消毒程序的两种关键实现方法：程序检测技术（第5节）和元数据管理（第6节）。然后，我们简要讨论如何用消毒程序方式去驱动一个程序，以及如何最大化地发挥消毒程序的功效（第七节）。接下来，我们将介绍正在积极维护种 或在学术会议上发布过的消毒程序的一个汇总，重点是其精度，兼容性和性能/内存成本（第八节）。我们还将调查这些工具的部署情况（第IX节）。我们以研究方向的未来展望作为论文的结尾（第十节）。

## 2、EXPLOIT MITIGATIONS VS. SANITIZERS

​        消毒程序在许多方面类似于许多众所周知的漏洞利用缓解措施，它们可以以类似的方式来检测程序，例如，通过插入嵌入式参考监视器（IRM）。尽管有这些相似之处，但缓解利用漏洞措施和消毒程序的目标和用例却大不相同。我们在表I中总结了主要差异。

<p align="center">表1 Exploit mitigations VS Sanitizers</p>

|                    | 漏洞利用缓解措施 | 消毒程序 |
| ------------------ | ---------------- | -------- |
| 目标               | 缓解攻击         | 查找漏洞 |
| 应用场景           | 生产             | 预发行   |
| 绩效预算           | 非常有限         | 高得多   |
| 违规结果           | 程序终止         | 问题诊断 |
| 在错误位置触发违规 | 有时             | 总是     |
| FPs公差            | 零               | 更高一点 |
| 残差良性错误的结果 | 期望的           | 不想要的 |

​        两种工具之间的最大区别在于它们执行的安全策略的类型。利用缓解措施部署旨在检测或预防攻击的策略，而消毒程序则旨在查明错误的程序语句的确切位置。控制流完整性（CFI）[10]，[11]，数据流完整性（DFI）[12]和写完整性测试（WIT）[13]是缓解漏洞的示例，因为它们检测到与合规的控制流或数据流路径之间的偏差，这通常是由于漏洞的利用而发生的，但不一定非得发生在易受攻击的程序语句的确切位置。相反，可以将边界检查工具视为消毒程序，因为违反其策略的行为直接在易受攻击的语句位置触发。

​        一些工具有选择地应用消毒技术，可能还结合了漏洞利用缓解措施的技术。例如，代码指针完整性（CPI）仅在程序直接或间接访问敏感代码指针时才执行边界检查（许多消毒程序中使用的一种消毒程序技术）[14]。因此，我们将CPI视为一种漏洞利用缓解措施的方法，而不是一种消毒程序，因为CPI仅检测可以使用边界检查检测到的所有错误的一小部分。

​        漏洞利用缓解措施的目的是在生产中部署，因此对各个设计方面提出了严格的要求。首先，漏洞利用缓解措施如果导致不可忽略的运行时间开销，则很少能被实际采用[15]。消毒程序对性能的要求不那么严格，因为它们仅用于测试。第二，漏洞利用缓解措施中的误报检测是不可接受的（也就是对容错性要求较高），因为它们会终止程序。而如果开发人员本意是查看错误报告（报错日志），则消毒程序可以容忍错误的警报。最后，出于可靠性和可用性的原因，在生产系统中允许存在残差的良性错误（例如，写入填充），并且经常会希望这种良性错误；而消毒程序的目的是精确地检测这些错误，因为它们的可利用性（就是程序到底会不会执行到这一段代码）未知。

## 3. LOW - LEVEL VULNERABILITIES

​        鉴于与安全性相关的漏洞种类繁多，我们将重点介绍在C / C ++中具有特定安全性的漏洞。这不仅包括未定义的行为，还包括在缺乏类型和内存安全性的情况下可能具有潜在危险的定义良好的行为。我们简述这些错误以及如何利用它们来泄漏信息、提升特权或执行任意代码。

### 3.1 违反内存安全(Memory Safety Violations)

​        如果程序中的指针仅访问其  intended referents，而这些预期的引用是有效的，则该程序是 memory safe 。指针的预期对象是从其基址派生指针的对象。根据引用对象的类型，它在其分配和释放之间（对于堆分配的引用对象）、在函数调用与其返回（对于堆栈分配的引用对象）之间，在其关联线程的创建和销毁之间都是有效的（对于线程本地引用）或无期限的（对于全局引用）。

​        违反内存安全性是最严重的安全漏洞之一，并且在文献[15]，[16]中进行了广泛的研究。他们的利用可能导致代码注入[17]，控制流劫持[1]，[18]，[19]，特权升级[20]，信息泄漏[21]和程序崩溃。

#### 3.1.1 空间安全违规 ( Spatial Safety Violations)：

​        访问不（完全）在指针的预期引用范围之内的内存构成空间安全违规。缓冲区溢出是违反空间安全性的典型示例。当程序超出缓冲区末尾写入时，将发生缓冲区溢出。如果易受攻击的访问的目标对象是一个子对象（例如，结构字段），并且如果攻击者在同一对象内写入另一个子对象，则我们将其称为  intra-object overflow 。清单1显示了一个对象内溢出漏洞，可以利用该漏洞执行特权升级攻击。

<p align="center">清单1. 对象内溢出漏洞，可以利用该漏洞重写对安全敏感的、非控制数据</p>

```c
struct A { char name[7]; bool isAdmin; };
struct A a; char buf[8];
memcpy(/* dst */ a.name, /* src */ buf, sizeof(buf));
```

#### 3.1.2 违反时间安全性(Temporal Safety Violations)：

当程序访问不再有效的引用时，发生违反时间安全性的行为。当一个对象变为无效时（通常是通过显式地对其进行分配），指向该对象的所有指针都将变为 dangling 。通过悬空指针访问对象被称为  use-after-free。访问的其范围或在函数返回之后本地对象外分别被称为  use-after-scope 和 use-after-return 。当攻击者可以重用和控制释放的区域时，这种类型的漏洞就可以被利用，如清单2所示。

<p align="center">清单2. Use-after-free 的漏洞，可以被利用来劫持程序的控制流</p>

```c
struct A { void (*func)(void); };
struct A *p = (struct A *)malloc(sizeof(struct A));
free(p); // Pointer becomes dangling
...
p->func(); // Use-after-free
```

### 3.2 使用未初始化的变量(Use of Uninitialized Variables)

​        变量在初始化之前具有  indeterminate value [22]，[23]。如果源变量和目标变量都具有无符号的窄字符类型，则C++14允许将此不确定值赋给其他变量。任何未初始化变量的使用都会导致未定义的行为。这种不确定行为的影响取决于许多因素，包括用于编译程序的编译器和编译器标志。在大多数情况下，不确定值实际上是先前释放的变量的（部分）内容，这些变量所占用的内存位置与未初始化的变量相同。由于这些先前释放的变量有时可能对安全性敏感值，未初始化的内存的读取可能是信息泄漏攻击的一部分，如清单3所示。

<p align="center">清单3.使用部分初始化的变量，该变量在未初始化的值越过可信任边界时会变得易受攻击</p>

```c
struct A { int data[2]; };
struct A *p = (struct A *)malloc(sizeof(struct A));
p->data[0] = 0; // Partial initialization
send_to_untrusted_client(p, sizeof(struct A));
```

### 3.3 指针类型错误（Pointer Type Errors）

​        C 和 C ++ 支持多种强制转换运算符和语言构造，这些构造运算符和语言构造可能导致内存访问错误地解释了其引用对象中存储的数据，从而违反了类型安全性。指针类型错误通常是由不安全的强制转换引起的。C 允许在指针类型之间进行所有类型转换，包括在整数和指针类型之间进行类型转换。同样，C++ reinterpret_cast 类型转换运算符不受任何限制。而 static_cast 和 dynamic_cast 的操作有所限制限制。static_cast 禁止指向整数强制转换的指针，以及禁止指向与继承无关的对象的指针之间的强制转换。但是，它的确允许将指针从基类强制转换为派生类（也称为downcasting ），以及从void 类型进行的所有强制转换。当向下转换的指针既没有其引用对象的运行时的类型，也没有引用对象的祖先类型之一时，就会发生 bad-casting（通常称为 type confusion）。

<p align="center">清单4. 错误转换漏洞导致类型和内存不安全的内存访问</p>

```c
class Base { virtual void func(); };
class Derived : public Base { public: int extra; };
Base b[2];
Derived * d = static_cast<Derived * >(&b[0]); // Bad-casting
d->extra = ...; // Type-unsafe, out-of-bounds access, which
                // overwrites the vtable pointer of b[1]
```

​        为了安全地向下转换，程序员必须使用 dynamic_cast 运算符，该运算符执行运行时类型检查，如果检查失败，则返回空指针。但是，使用 dynamic_cast 完全是可选的（非必需的），并且会带来额外的运行时开销。

​        在函数指针类型之间进行转换时，也会发生类型错误。同样，C ++ 的 reinterpret_cast 和 C 对不兼容的函数指针类型之间的强制转换没有任何限制。如果通过错误类型的函数指针间接调用函数，则目标函数可能会错误地编译(误解)其参数，从而导致更多类型错误。最后，C 还允许通过 union 类型进行类型修剪。如果程序通过转换实际存储数据的成员对象到不同的其他类型成员对象的方式去读取 union，则可能会误解底层的内存内容。此外，如果用于读取的成员对象大于用于存储数据的成员对象，则从 union 中读取的高位字节将采用未指定的值。

### 3.4 可变参数功能滥用 ( Variadic Function Misuse)

​    C / C ++支持  variadic functions，除了固定数量的常规函数参数外，它们还接受可变数量的可变长函数参数。可变参数函数的源代码未指定这些可变参数的数量或类型。相反，固定参数和函数语义对可变参数的预期数量和类型进行编码。可变参数可以使用 va_arg 进行访问并同时进行类型转换。通常，不可能静态验证 va_arg 访问有效参数，或将参数转换为有效类型。缺少静态验证会导致类型错误，违反空间内存安全性以及使用未初始化的值。

<p align="center">清单5. CVE-2012-0809的 简化版本；用户提供的输入<br>被误用作传递给类似 printf() 的较大格式字符串的一部分</p>

```c
char * fmt2; // User-controlled format string
sprintf(fmt2, user_input, ...);
// prints attacker-chosen stack contents if fmt2 contains
// too many format specifiers
// or overwrites memory if fmt2 contains %n
printf(fmt2, ...);
```

### 3.5 其他漏洞 (Other Vulnerabilities)

​        在没有类型和内存安全性的情况下，还有其他操作可能会带来安全风险。值得注意的例子包括溢出错误，当在内存分配或指针算术运算中使用此类值时，可能会利用这些错误。如果使用攻击者控制的整数值来计算缓冲区大小或数组索引，则攻击者可能使该值溢出以分配比预期小的缓冲区（如清单6所示），或者绕过现有的数组索引检查，从而触发一个出界外的访问。

<p align="center">清单6. CVE-2017-5029的简化版本；有符号整数溢出漏洞，<br>可能导致违反空间内存安全性</p>

```c
// newsize can overflow depending on len
int newsize = oldsize + len + 100;
newsize * = 2;
// The new buffer may be smaller than len
buf = xmlRealloc(buf, newsize);
memcpy(buf + oldsize, string, len); // Out-of-bounds access
```

​        C / C ++并未定义有符号整数溢出的结果，但规定无符号整数溢出时会回绕。但是，这种环绕行为通常是意料之外的，并且有潜在的危险。

​        启用编译器优化后，未定义的行为（例如，有符号整数溢出）会带来额外的安全风险。在存在潜在未定义行为的情况下，编译器被默认允许假定程序将永远不会达到触发此未定义行为的条件。而且，编译器可以基于此假设[24]执行进一步的优化。因此，编译器不必静态验证程序是否没有潜在的未定义行为，并且编译器没有义务生成能够识别或减少未定义行为的代码。这个基本原理的问题在于，基于程序没有未定义行为的假设进行的优化有时会导致编译器忽略安全检查。例如在CVE-2009-1897中，海湾合作委员会臭名昭著地省略了Linux内核驱动程序之一中的空指针检查，这导致了提权漏洞[25]。编译器开发人员会定期向其编译器中添加此类积极的优化。因此，有些人将未定义的行为称为 time bombs [26]。

<p align="center">清单7. CVE-2009-1897的简化版本；取消引用指针<br>可使编译器安全地假定指针为非null</p>

```c
struct sock *sk = tun->sk; // Compiler assumes tun is not 
                           // a null pointer
if (!tun) // Check is optimized out
    return POLLERR;
```

## 4. BUG FINDING TECHNIQUES

​        现在，我们回顾相关的错误查找技术。我们在每个小节中都以对错误发现策略的非正式描述开头，然后对实现（或近似）该策略的机制进行描述。

### 4.1 违反内存安全 (Memory Safety Violations)

​        内存安全错误查找工具会检测未针对其预期目标（即，违反空间安全）或针对不再有效的目标（即，违反时间安全）的指针的间接引用。有两种检测这些错误的工具。我们在这里总结了它们的高级目标和属性，然后深入讨论了这些工具可用来检测内存安全错误的技术。

**基于位置的访问检查器 (Location-based Access Checkers)：**

​        基于位置的访问检查器检测内存访问无效的内存区域。这些检查器具有一个元数据存储，该存储可维护每个字节（一部分）可寻址地址空间中的状态，并且每当程序尝试访问内存以确定内存访问是否有效时，都应查阅该元数据存储。基于位置的访问检查器可以使用 red zones插入 [27] – [31]或保护页[32]，[33]来检测空间安全违规情况。这些技术中的任何一种都可以与重用延迟结合使用，以另外检测时间安全性违规 [27]-[29]， [31]-[36]。 基于位置的访问检查器的费用较低运行时性能开销，并且与非仪表代码（uninstrumented code）高度兼容。缺点是这些工具不精确，因为它们只能检测指令是否访问有效内存，而*不能检测访问的内存是否是指令的预期对象的一部分( not if the accessed memory is part of the intended referent of the instruction)*。这些(?)工具通常会导致高内存开销。

**基于身份的访问检查器（Identity-based Access Checkers):**

​        基于身份的访问检查器检测与预期引用对象不匹配的内存地址访问。这些工具为每个分配的内存对象维护元数据（例如，边界或分配状态），并且具有适当的机制来确定程序中每个指针间接引用以确定该引用是否访问该指针的预期引用时，会发生元数据查找。基于身份的访问检查器可以使用按对象边界跟踪[34]， [37]-[43]或按指针边界跟踪[44] – [55] 可以检测到违反空间安全的行为，并且可以通过重用延迟[55]，锁定和钥匙检查[46]，[47]，[56]或悬置指针标记[57] – [60] 进行扩展。检测临时安全违规。基于身份的检查器比基于位置的访问检查器更为精确，因为它们不仅可以检测到对无效内存的访问，而且还可以检测对预期对象以外的有效内存的访问。但是，与基于位置的检查器相比，这些工具确实会带来更高的运行时性能开销。基于身份的检查器通常与非仪表代码不兼容。他们的假阳性检出率也比基于位置的检查器。

#### 4.1.1 违反空间内存安全 (Spatial Memory Safety Violations)：

**红色区域插入 (Red-zone Insertion)**：

​        基于位置的访问检查器可以在内存对象 [27] – [31]之间插入所谓的  red-zones。这些 red-zones 表示内存访问越界，并在元数据存储中标记为无效内存。对 red-zones 或未分配的内存区域的任何访问都会触发警告。Purify 是采用该技术的第一个工具[27]。Purify 在每个分配的开始和结束插入 red zones。Purify使用大型影子内存位图跟踪程序分配的地址空间的状态，该位图在每个字节的内存中存储两位状态。Valgrind 的 Memcheck 使用相同的技术，但为内存的每一位保留两位状态[28]。因此，Memcheck 能够以字级精度而不是字节级精度检测访问错误。

​        轻量级边界检查（LBC）同样会插入 red zones，但为基于位置的访问检查添加了一条快速路径，以减少元数据查找的开销[30]。LBC 通过用随机模式填充 red zones 来做到这一点，并将每个内存访问读取/覆盖的数据与填充模式进行比较。如果数据与填充模式不匹配，则认为该访问是安全的，因为它不可能被标记为 red zones。如果数据确实符合填充模式，则 LBC 将执行辅助慢路径检查，以查找元数据存储中已访问数据的状态，并在已访问数据为 red zones 时触发警告。

​        使用红区插入的基于位置的访问检查器通常会产生较低的运行时性能开销，但精度有限，因为它们只能检测到针对红区的非法访问。以有效对象为目标的非法访问是无法检测到，因为该对象与预期的对象可能同为某一分配的一部分，也可能不是的。基于 red zones 插入的工具也无法检测对象内部的溢出错误，因为它们没有在子对象之间插入 red zones。在技术上可行时，插入子对象间的 red zones 时会导致过多的内存开销，并且会更改父对象的布局。因此，必须修改访问父对象或其子对象之一的任何代码，这也将破坏未意识到数据布局已更改的外部代码的兼容性。

**保护页面 (Guard Pages)**：

​        基于位置的访问检查器可以在每个分配的内存对象[32]-[33]之前和(或)之后插入不可访问的保护页面。访问保护页的越界读取和写入会触发页面错误，这又会触发应用程序中的异常。使用分页硬件检测非法访问允许基于位置无需检查单个 load 和 store 指令即可访问检查程序。但是，使用保护页确实会导致高内存开销，从而使该技术对于具有较大工作集的程序不切实际。Microsoft 意识到了这个问题，并在 PageHeap [33]中添加了一个选项，使内存对象带有保护块而不是完整的保护页。PageHeap 使用填充模式填充这些保护块，并保证释放内存对象时该模式仍然存在。此技术严格不如红区插入，因为它仅检测越界写入(而不读取)，并且除非要写入的对象被释放，否则不会检测到非法写入。

**每个指针的边界跟踪(Per-pointer Bounds Tracking)：**

​        基于身份的访问检查器可以存储每个指针的边界元数据[44]-[55]。每当程序通过调用 malloc 或通过获取对象的地址创建指针时，跟踪器都会为新指针将其引用对象的基址和空间大小存进元数据。当程序通过算术和赋值运算计算新的指针时，跟踪器将传播(propagates)此元数据。通过检测所有指针间接引用并检查指针在简介引用时是否在其关联边界之外，可以检测到空间内存安全冲突。

​        使用基于指针的边界跟踪的基于身份的访问检查器可以提供完整的空间内存冲突检测，包括检测对象内溢出。每当程序从子对象的地址（即结构域）派生指针时，SoftBound [48]和 Intel Pointer Checker [49] 通过将指针范围缩小到子对象的边界来检测对象内溢出。每指针边界跟踪的主要缺点是兼容性差，因为该程序通常无法将指针传递给未插入库，因为此类库无法正确传播或更新边界信息。另一个缺点是每个指针元数据传播会增加运行时的开销。CCured 通过标识“安全”指针来减少这种开销，可以将其从边界检查和元数据传播中排除[50]。然而，即使有了这种优化，没有硬件支持，每个指针的边界检查仍然很昂贵。

**每个对象的边界跟踪(Per-object Bounds Tracking)**：

​        基于身份的访问检查器还可以存储每个内存对象的边界元数据，而不是每个指针的边界元数据[34]， [37] – [43]。

​        这种方法是由 Jones 和 Kelly（下称：“J＆K”）率先提出的，解决了一些与每指针边界跟踪有关的兼容性问题[34]。Per-object Bounds Tracking 可以维护边界元数据，而无需检测指针的创建和分配操作。跟踪器仅需要拦截对内存分配（即 malloc ）和释放（ 即free ）函数的调用，即使在未完全检测的程序中也可以实现。由于边界元数据仅为对象而不是指针维护，因此很难将指针链接到其预期的引用对象。虽然内部指针类型的预期引用对象可以使用基于（生命周期）范围的查找，来在元数据中的存储，但这样的查找将不会为越界（out-of-bounds OOB）指针返回正确的元数据。因此，J＆K建议对指针算术运算进行检测，并在指针发生 OOB 时使其无效。任何后续间接引用都会触发故障，然后可以捕获该故障以输出警告。

​        但是，J＆K的方法破坏了许多使用 OOB指针执行计算的现有程序。有鉴于此，CRED通过跟踪OOB指针的引用信息来支持其创建和操作[37]。CRED 将 OOB 指针链接到所谓的 OOB objects，这些 OOB objects 存储每个OOB指针的原始引用地址。

​        Baggy Bounds Checking（BBC）通过将 OOB 指针与其引用对象之间的距离存储到指针的最大有效位[39]距离中，从而无需分配专用的 OOB 对象。标记最重要的位还会将 OOB 指针变成无效的用户空间指针，因此释放它们会导致错误。BBC 通过将所有分配大小四舍五入到最接近的二次方值来压缩每个对象元数据的大小，以便一个字节的元数据可以存储边界。

​        Low-fat pointer（LFP）边界检查器通过使分配大小可配置来改善BBC，这导致较低的性能和内存开销[42]，[43]。这个想法是将堆分成相等大小每个子堆仅支持一个分配大小。因此，可以通过查找该堆支持的分配大小来获取任何给定指针的分配大小。指针引用对象的基地址可以通过将其舍入为分配大小来计算。LFP 在处理 OOB 指针方面也不同于 BBC。为了与 uninstrumented libraries 更好地兼容，LFP 不会操纵指针表示来对 OOB 指针的引用进行编码。取而代之的是，只要将指针作为显式输入（例如，将指针作为自变量指定）或隐式（例如，从内存中加载的指针）作为函数的输入提供给函数，LFP 都会重新计算每个指针的引用。但是，这要求LFP强制执行不变式，即只要将指针作为其他函数的输入给出，这样在实际程序中好像太严格了（参阅8.1节）。

​        Per-object bounds trackers 可以支持接近完整的空间安全漏洞检测。但是，诸如 BBC 和 LFP 之类的技术确实舍弃了精度，以获得更好的运行时性能----因为它们舍入了分配大小并检查了分配范围而不是对象范围（参见VIII-B节）。

​        Per-object bounds trackers 还有其他缺点。首先，每个对象的边界跟踪器不会检测到对象内部的溢出（参阅8.2节）。其次，通过将指针指向OOB对象或将标记写入其高位标记为OOB可能会影响与未意识到程序中使用的边界检查方案的外部代码的兼容性。特别是，即使意识到了，外部代码也无法将 OOB 指针还原为内部普通入栈指针。

#### 4.1.2 违反时间内存安全 (Temporal Memory Safety Violations)：

**重用延迟 (Reuse Delay):**

​        基于位置的访问检查器可以通过替换为 red zones [27] – [29]， [31]，[34]或guard pages[32]，[ 33]，[35]，[36]来标记新近被释放的对象为非法的元数据。Identity-based checkers 可以用类似的方法使已释放对象的身份无效[55]。只要不重新使用已释放的内存或标识，现有的访问检查机制就可以检测到悬空的指针间接引用。当然如果程序为了重新分配重用了内存或标识，则这种方法将错误地允许悬空指针间接引用继续进行下去（？）。一些基于重用延迟的工具通过延迟内存区域或标识的重用，直到它们“老化” [27] – [29]， [31]，[34]，[55]，来减少此类检测失败的机会。由于较长的重用延迟会导致较高的内存开销，因此这会导致精度与内存开销之间的取舍，而且还会有更大的机会检测悬空指针的间接引用。

​        Dhurjati和Adve（D＆A）建议使用静态分析确定释放的内存何时可以安全重用[35]。D＆A在其自己的虚拟内存页面上分配每个内存对象，但是通过将虚拟内存页面别名到同一物理页面来允许对象共享物理内存页面。当程序释放内存对象时，D＆A会将其虚拟页面转换为 guard page。D＆A还利用称为 Automatic Pool Allocation 的静态分析，将堆划分为池[62]。这种分析可以推断何时不再可以访问池（即使是潜在的悬空指针），此时可以回收池中的所有虚拟页。党等 有人提出了一种不使用池分配的类似系统，因此可以将其应用于无源程序[36]。与D＆A类似，Dang等。在自己的虚拟页面上分配所有内存对象。释放对象后，Dang等人取消映射该对象的虚拟页面。这有效地实现了与保护页面相同的目标，但允许内核释放其用于虚拟页面的内部元数据，从而减少了物理内存开销。为了防止重用未映射的虚拟页面，Dang等人，建议在高地址位（即程序中使用的最高虚拟地址）处映射新页面。尽管这并不排除完全重用未映射的虚拟页面，但理论上在64位地址空间情况，不太可能发生重用。

**锁和密钥 (Lock-and-key)：**

​        基于身份的检查器可以通过为每个分配的内存对象分配唯一的分配标识符（通常称为密钥）并将此密钥存储在  lock location 来检测时间安全违规[46]，[47]，[ 56]。它们还为每个指针的元数据存储  lock location 和期望的密钥。当释放其关联对象时，检查器会从锁定位置撤消密钥。当程序间接引用其密钥与该指针的  lock location 中存储的密钥不匹配的指针时，锁定和密钥检查会检测到时间安全违规。假设使用唯一的密钥，此方法将完全涵盖临时安全违规行为[56]。由于此技术存储每个指针的元数据，它自然补充了使用 per-pointer bounds tracking 来检测空间违规的 identity-based checkers。 lock-and-key 检查器的缺点与 per-pointer bounds tracking 的缺点基本相同：与 uninstrumented code 的兼容性很差，因为 uninstrumented code 无法正确找到元数据；并且运行时开销很大，因为维护用于每个指针都很昂贵。

**悬空指针标记 (Dangling Pointer Tagging )**：

​        标记悬空指针的最直接方法是使调用 free() 函数的指针相关联的值和边界无效[49]。如果在以后的某个时间点间接引用这样的指针，则空间内存安全违规检测机制将触发警告。这种方法的缺点是它不标记悬挂指针的副本，后者以后也可以使用。

​        有几种工具不仅通过标记调用 free() 的指针，还通过维所有内存对象链接到引用它们的任何指针的辅助数据结构，来标记该指针的副本[57] – [60]。Undangle 使用污点跟踪[63]-[65]跟踪指针的创建，并维护对象到指针的映射[57]。

​        每当程序释放内存对象时，Undangle 都可以查询该指针映射，以快速找到指向当前已释放对象的所有悬空指针。Undangle旨在不仅报告使用情况，而且还报告悬挂指针的存在。它有一个可配置的时间窗口，其中它认为悬空指针是潜在的但并非不安全，例如，在嵌套对象释放期间出现的瞬时悬空指针。当此窗口到期时，或更早在程序尝试间接引用该指针时，Undangle报告悬空的指针。

​        DangNull [58]，FreeSentry [59]和DangSan [60]在编译时避开了污点跟踪和工具指针的创建。只要程序分配了指针，这些工具就会通过调用一个称作运行时注册的函数来维护指针映射。每当程序释放内存对象时，工具都会查找所有指向要释放对象的指针，并使它们无效。无效的悬挂指针的后续间接引用会导致硬件陷阱。

​        不基于污点跟踪的悬空指针标记工具具有一些基本限制。首先，它们需要源代码？的可用性，因为源依赖精确的类型信息来确定哪些操作存储新的指针。其次，如果程序以类型不安全的方式（例如，通过将其强制转换为整数）复制指针，则它们将无法维护准确的元数据。第三，也是最重要的是，它们只能将对象链接到存储在内存中的指针，因此不知道存储在寄存器中的指针悬空。基于污点跟踪的工具（例如Undangle）没有这些缺点，但是会带来明显的性能和内存开销。



## V. PROGRAM INSTRUMENTATION



## VI. META DATA MANAGEMENT



## VII.  RIVING A SANITIZER



## VIII. ANALYSIS



## IX. DEPLOYMENT



## X. FUTURE RESEARCH AND DEVELOPMENT DIRECTIONS

